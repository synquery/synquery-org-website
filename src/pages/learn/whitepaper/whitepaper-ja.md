---
title: Synquery ホワイトペーパー
description: 2021 年に発案され基本構想が確立された Synquery crypto-network についての紹介文書です
lang: ja
sidebar: true
sidebarDepth: 2
---

# Synquery Whitepaper

_本紹介文書の原案は、Synquery crypto-network がプロトコルアクティベートされるに先立ち 2021 年に発表された「[Synquery crypto-network の提案](/ja/what-is-the-crypto/)」 に拠ります。このコミュニティ主体のオープンソースソフトウェアプロジェクトは産声をあげたばかりですが、多くの賛同を集めながら胎動しており、いま注目するに値するもののひとつと言えるでしょう。_

_遡ること数年前、Synquery（シンクエリ）は Web 上の統合的な開発・運用基盤として株式会社東雲より提供されていましたが、その基本プラットフォームは無償で提供されており、またその使い道について多くの人が模索している段階にありました。我々はより多くのユーザーにメリットをもたらすにはどうしたらよいか思案に耽っていました。その答えがブロックチェーンテクノロジー、とりわけ [イーサリアム(Ethereum)](https://ethereum.org/) と [シンボル(SYMBOL)](https://symbolplatform.com/) が実現した仕掛けにあることに気づくのには、少し時間を要しました。しかし我々はたどり着きました。その理由を知るには多くの知識を得る必要があります。どのような情報が我々、そして Synquery を導いたのか、その背景を詳しく知るには [ガイド](/learn/) を参照してください。_

## スマートコントラクトが社会で広まるために {name=smart-contract-in-society}

クラウドコンピューティングがインターネットサービスの基礎となりはじめた 2010 年頃、サトシ・ナカモトのビットコインは、裏付けのある「[実質的資産](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)」として注目される対象となりました。法定通貨の代替候補などにさえ、しばしば歓迎されています。この仕組みにおいて決められたプロトコル外の力で価値をコントロールする支配者はいません。ただし、ビットコインがもたらしたもう 1 つの、おそらくより重要な部分は、分散コンセンサスのツールとしての基盤となるブロックチェーンテクノロジーであり、ビットコインのこの側面に注目が急速に移り始めています。ブロックチェーンテクノロジーの一般的に引用される代替アプリケーションには、ブロックチェーン上のデジタル資産を使用してカスタム通貨や金融商品を表現することが含まれます（[colored coins](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/)）。基盤となる物理デバイスの所有権の管理（[smart property](https://en.bitcoin.it/wiki/Smart_Property)）、ドメイン名などの非代替資産（[Namecoin / NFT](http://namecoin.org)）、および任意のルールを実装するコードの一部によってデジタル資産を直接制御することを含むより複雑なアプリケーション（[Optimized Smart Contract](http://www.fon.humuva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html)）またはブロックチェーンベースの「[分散型自律組織](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/) 」（DAO: Decentralized Autonomous Organization）。Synquery が提供しようとしているのは、これらの仕組みを一般的にする汎用化テクノロジーであり、ブロックチェーンであり、プラットフォームです。ユーザーは任意の価値を上記のシステムのいずれかに変換できますが、Synquery crypto-network の mainnet では時間を利用する人（Human）がある場所にいることを「予想し、実際に時間を過ごす」（sync）により価値が生まれる、社会的な仕組みです。

### Synquery の解決する課題 {name=challenge-of-synquey}

ブロックチェーン、とりわけ暗号資産のキーフレーズのひとつは「Don't trust, verify」（信頼するなかれ、確認せよ）です。
この仕組みの自動化に成功したことにより、ブロックチェーンは不特定多数の参加者が運営コミュニティを形成することに成功しました。そして巨大な「信頼できる」システムを構築した企業からの金融システムの離脱を可能にし、大きな評価を得ました。

その反面「確認コスト」はいつまでも小さくいることはできません。なぜならば暗号資産の価値が高まるほど、コミュニティの参加者はより好条件を求めるからです。その先が利用不可能なほどのコスト増加に繋がるかどうかはまだ結論が出ていませんが、少なくともトランザクション速度の低下は利用者に不利益を
もたらすことが証明されています。次々に [ERC-20](https://ethereum.org/ja/developers/docs/standards/tokens/erc-20/) 上にライトニングネットワークが構築されているのはそういった理由からです。
Synquery crypto-network は時間と信用を「信頼できる」システムがモデレートすることでこの問題を解決し、
価値ある暗号資産がより大きなムーブメントを起こし生活に浸透し、これまで以上に社会を活性化することを目的としています。

## ビットコインと既存の概念の紹介 {name=introduce-to-bitcoin}

_本項は Ethereum グループが提供する項およびウェブ上の情報を引用し、要約を加えながら記載しております。_  
_不手際がありましたら、[github](https://github.com/synquery/synquery-org-website) もしくは [discord](https://discord.gg/ujvecKQ8aG) を通じてご連絡ください。_

### ビットコインの歴史 {name=history-of-bitcoin}

分散型デジタル通貨の概念や代替資産などのアプリケーションは、何十年も前から存在しています。 1980年代と1990年代の匿名の電子現金プロトコルは、主に高い匿名性を達成している Chaumian CoinJoin（チャウミアン・コインジョイン）というスキームに依存しており、高度なプライバシーを備えた通貨を提供しましたが、プロトコルは集中型の仲介者に依存しているため、ほとんど牽引力を得ることができませんでした。 1998年、Wei Dai の [b-money](http://www.weidai.com/bmoney.txt) は、計算パズルの解決と分散型コンセンサスを通じてお金を生み出すというアイデアを導入した最初の提案になりましたが、その提案は分散型コンセンサスを実際にどのように実装できるかについての詳細はほとんどありません。 2005 年、Hal Finney は、「[再利用可能なプルーフオブワーク(PoW)](https://nakamotoinstitute.org/finney/rpow/)」の概念を導入しました。これは、b-money のアイデアと AdamBack の計算が難しいハッシュキャッシュパズルを使用するシステムです。暗号通貨の概念を作成しますが、バックエンドとして信頼できるコンピューティングに依存することにより、再び理想に達しませんでした。 2009年、分散型通貨は、公開鍵暗号による所有権を管理するための確立されたプリミティブと、コインの所有者を追跡するためのコンセンサスアルゴリズム（昨今の暗号資産においての「プルーフオブワーク」と呼ばれるもの）を組み合わせて、サトシ・ナカモトによって初めて実際に実装されました。

プルーフオブワークの背後にあるメカニズムは、2つの問題を同時に解決したため、この分野でのブレークスルーを達成しました。まず、シンプルで適度に効果的なコンセンサスアルゴリズムを提供し、ネットワーク内のノードがビットコイン台帳の状態に対する一連の正規の更新について集合的に合意できるようにしました。第二に、それはコンセンサスプロセスへの自由な参入を可能にするメカニズムを提供し、誰がコンセンサスに影響を与えるかを決定するという政治的問題を解決すると同時に、攻撃を防ぎます。これは、特定のリストに一意のエンティティとして登録する必要があるなど、参加に対する正式な障壁を経済的な障壁に置き換えることによって行われます。コンセンサス投票プロセスにおける単一ノードの重みは、コンピューティング能力に正比例します。その後、_プルーフオブステーク(PoS)_ と呼ばれる代替アプローチが提案されており、ノードのウェイトを、計算リソースではなく、保有する通貨に比例するものとして計算します。 2つのアプローチの相対的なメリットの説明はこのホワイトペーパーの範囲を超えていますが、いずれかのアプローチが暗号通貨のバックボーンとして機能できることに注意してください。

### ビットコインの状態変化システム {name=state-transition-of-bitcoin}

![Bitcoin state transition](https://synquery.github.io/pages/images/state-transition.png)

技術的な観点から、ビットコインなどの暗号通貨台帳は、既存のすべてのビットコインの所有権ステータスで構成される「状態」`S` と、状態を取得する「状態遷移関数」が存在する状態遷移システムと考えることができます。トランザクションと結果である新しい状態を出力します。たとえば、標準的なバンキングシステムでは、状態とは貸借対照表であり、トランザクション `TX` は移動資金 $X を A から B に移動する要求であり、状態遷移関数は A のアカウントの値を $X 減らし、B の値を $X 増やします。 そもそも A のアカウントの $X 未満の場合、状態遷移関数はエラーを返します。したがって、正式に次のように定義できます。

    APPLY(S,TX) -> S' or ERROR

上で定義されたバンキングシステムでは：

    APPLY({ Alice: $90, Bob: $10 },"send $40 from Alice to Bob") = { Alice: $50, Bob: $50 }

持ち高が不足している場合：

    APPLY({ Alice: $90, Bob: $10 },"send $1200 from Alice to Bob") = ERROR

ビットコインの「状態」は、暗号化されてまだ使用されていないすべてのコイン（技術的には「未使用のトランザクション出力（UTXO:Unspent Transaction Output）」）のコレクションであり、各 UTXO には資産種別と所有者があります。本質的には暗号化された公開鍵<sup> [fn.1](./#notes) </sup>　です。トランザクションには 1 つ以上の入力が含まれ、各入力には既存の UTXO への参照と、所有者のアドレスに関連付けられた秘密鍵によって生成された暗号署名が含まれ、1 つ以上の出力には、追加される新しい UTXO が含まれます。

状態遷移関数は `APPLY(S,TX) -> S'` 大きく以下の手順で示すことができます。

1. `TX` の入力ごとに：
   - 参照されている UTXO が `S` にない場合は、エラーを返します。
   - 提供された署名が UTXO の所有者と一致しない場合は、エラーを返します。
2. すべての入力 UTXO の金種の合計が、すべての出力 UTXO の金種の合計よりも小さい場合は、エラーを返します。
3. 問題がない場合、すべての入力 UTXO を削除し、すべての出力 UTXO を追加して `S'` を返します。

最初のステップの前半は、トランザクションの送信者が存在しないコインを使うのを防ぎ、最初のステップの後半は、トランザクションの送信者が他の人のコインを使うのを防ぎ、次のステップは価値の保存を強制します。これを支払いに使用するためのプロトコルは次のとおりです。アリスが 11.7BTC をボブに送信したいとします。まず、アリスは、合計で少なくとも 11.7BTC まで所有している利用可能な UTXO のセットを探します。現実的には、アリスは正確に 11.7BTC を取得することはできません。彼女が得ることができる最小のものは 6 + 4 + 2 = 12 であると言います。次に、これら3つの入力と2つの出力を使用してトランザクションを作成します。最初の出力は、ボブのアドレスを所有者とする 11.7BTC であり、2番目の出力は残りの 0.3BTC の「変更」であり、所有者はアリス自身です。

### マイニング {name=mining}

![Mining blocks](https://synquery.github.io/pages/images/mining-blocks.png)

信頼できる一元化されたサービスにアクセスできれば、このシステムの実装は簡単です。中央サーバーのハードドライブを使用して状態を追跡し、説明どおりに簡単にコーディングできます。ただし、ビットコインでは分散型金融システムを構築しようとしているため、すべての人が取引の順序に同意できるように、取引システムとコンセンサスシステムを組み合わせる必要があります。ビットコインの分散型コンセンサスプロセスでは、ネットワーク内のノードが「ブロック」と呼ばれるトランザクションのパッケージを継続的に生成しようとする必要があります。ネットワークは、10 分ごとに約 1 つのブロックを生成することを目的としており、各ブロックには、タイムスタンプ、ナンス、前のブロックへの参照（つまり、ハッシュ）、および前のブロック以降に発生したすべてのトランザクションのリストが含まれます。ブロック。時間の経過とともに、これにより、ビットコイン元帳の最新の状態を表すために絶えず更新される、永続的で成長し続ける「ブロックチェーン」が作成されます。

このパラダイムで表される、ブロックが有効かどうかをチェックするためのアルゴリズムは次のとおりです。

1. ブロックによって参照されている前のブロックが存在し、有効であるかどうかを確認します。
2. ブロックのタイムスタンプが前のブロックのタイムスタンプよりも大きいことを確認します<sup>[fn.2](./#notes)</sup>。
そして2時間以内にブロックのプルーフオブワークが有効であることを確認します。
4. `S[0]`を前のブロックの終わりの状態とします。
5. `TX`が `n`トランザクションを持つブロックのトランザクションリストであると仮定します。`0 ... n-1` のすべての `i` について、 `S[i + 1] = APPLY（S[i]、TX[i]）` を設定します。異常を検知し、アプリケーションがエラーを返した場合は、終了して `false` を返します。
6. `true` を返し、このブロックの最後の状態として `S[n] = S'` を登録します。

基本的に、ブロック内の各トランザクションは、トランザクションが実行される前の正規の状態から新しい状態への有効な状態遷移を提供する必要があります。状態はブロックにエンコードされていないことに注意してください。これは、検証ノードによって記憶される純粋な抽象化であり、生成状態から開始し、すべてのブロックのすべてのトランザクションを順次適用することによってのみ、任意のブロックに対して（安全に）計算できます。さらに、マイナーがトランザクションをブロックに含める順序が重要であることに注意してください。ブロック内に2つのトランザクション A と B があり、B が A によって作成された UTXO を使用する場合、ブロックは A が B の前に来る場合に有効になりますが、そうでない場合は有効になりません。

上記のリストに存在し、他のシステムには見られない1つの有効条件は、「プルーフオブワーク」の要件です。正確な条件は、256 ビットの数値として扱われるすべてのブロックの倍精度浮動小数点 SHA256 ハッシュが、動的に調整されたターゲットよりも小さくなければならないことです。この書き込みの時点では、約2 <sup>187</sup>です。これの目的は、ブロックの作成を計算上「困難」にすることであり、それによって、攻撃者がブロックチェーン全体を自分たちに有利に作り直すことを防ぎます。 SHA256 は完全に予測不可能な疑似ランダム関数として設計されているため、有効なブロックを作成する唯一の方法は、試行錯誤を繰り返し、ナンスを繰り返しインクリメントして、新しいハッシュが一致するかどうかを確認することです。

現在のターゲットである〜2 <sup>187</sup>では、有効なブロックが見つかるまでに、ネットワークは平均で〜2 <sup> 69</sup>の試行を行う必要があります。一般に、ターゲットは 2016 ブロックごとにネットワークによって再調整されるため、平均して 10 分ごとにネットワーク内のノードによって新しいブロックが生成されます。この計算作業をマイナーに補償するために、すべてのブロックのマイナーは、どこからともなく 25BTC を与えるトランザクションを含める権利があります。さらに、いずれかのトランザクションの合計金額が出力よりも入力の方が高い場合、その差額は「トランザクション料金」としてマイナーにも送られます。ちなみに、これは BTC が発行される唯一のメカニズムでもあります。創世記の状態にはコインがまったく含まれていませんでした。

マイニングの目的をよりよく理解するために、悪意のある攻撃者が発生した場合に何が起こるかを調べてみましょう。ビットコインの基礎となる暗号化は安全であることが知られているため、攻撃者は暗号化によって直接保護されていないビットコインシステムの一部であるトランザクションの順序を標的にします。攻撃者の戦略は単純です。

1. 商品（デジタル商品とします）と引き換えに 100BTC を販売者に送信します。
2. 製品の配達を待ちます。
3. 同じ 100BTC を自分自身に送信する別のトランザクションを生成します。
4. 彼自身への取引が最初に行われたものであることをネットワークにミスリードします。

ステップ 1 が実行されると、数分後、一部のマイナーがトランザクションをブロック（ブロック番号 270000 など）に含めます。約 1 時間後、そのブロックの後にさらに 5 つのブロックがチェーンに追加され、それぞれがこれらのブロックは間接的にトランザクションを指し、したがってトランザクションを「確認」します。この時点で、売り手は支払いが確定したものとして受け入れ、製品を配達します。これはデジタル商品であると想定しているため、すぐに配達されます。ここで、攻撃者は 100BTC を自分自身に送信する別のトランザクションを作成します。攻撃者が単にそれを公開した場合、トランザクションは処理されません。マイナーは `APPLY（S、TX）` を実行しようとし、 `TX` が利用できる状態ではなくなった UTXO を消費していることに気付きます。したがって、代わりに、攻撃者はブロックチェーンの「フォーク」を作成します。まず、親と同じブロック 269999 を指す別のバージョンのブロック 270000 をマイニングしますが、古いトランザクションの代わりに新しいトランザクションを使用します。ブロックデータが異なるため、これにはプルーフオブワークをやり直す必要があります。さらに、攻撃者の新しいバージョンのブロック 270000 は異なるハッシュを持っているため、元のブロック 270001 から 270005 はそれを指し示しません。したがって、元のチェーンと攻撃者の新しいチェーンは完全に分離されています。ルールは、フォークでは最長のブロックチェーンが真実であると見なされるため、攻撃者だけが 270000 チェーンで作業している間、正当なマイナーは 270005 チェーンで作業します。攻撃者がブロックチェーンを最長にするためには、追いつくためにネットワークの他の部分を組み合わせたものよりも多くの計算能力が必要になります。（「51%攻撃」の名前で知られます。）

「51％攻撃」はこのプルーフオブワークのやり直しを成功させることです。通常のブロックチェーンでは 50% 超のマイナーがブロックの書き換えに同意することは起こり得ませんが、ネットワークにおけるスコア（ビットコインの場合は単純に計算量（ハッシュレート）と言えます）を闇雲に公開し誰もが取得できるようにすると、それに気づいた攻撃者が実施に踏み切ることは想像の難しくない事象です<sup> [fn.3](https://gigazine.net/news/20180529-51crypto/)</sup>。この攻撃の唯一の防護策はスコアの取得を容易にしないことですが、これは基本コンセプトである非中央集権化（Decentralization）や大量保有者によるラグ・プル攻撃（rug pull attack）の回避とはトレードオフの関係です。

### マークル木 {name=markle-tree}

![SPV in Bitcoin](https://synquery.github.io/pages/images/spv-bitcoin.png "SPV in Bitcoin")

_左: ブランチの有効性を証明するには、マークルツリーに少数のノードのみを表示するだけで十分です。_

_右: マークルツリーのいずれかの部分を変更しようとすると、最終的にはチェーンのどこかで不整合が発生します。_

ビットコインの重要なスケーラビリティ機能は、ブロックがマルチレベルのデータ構造に格納されていることです。ブロックの「ハッシュ」は、実際にはブロックヘッダーのハッシュ、タイムスタンプ、ナンス、前のブロックハッシュ、およびすべてのトランザクションを格納するマークル木（Merkle Tree) と呼ばれるデータ構造のルートハッシュを含む約 200 バイトのデータのみです。ブロック内。マークルツリーはバイナリツリーの一種であり、ツリーの下部に基になるデータを含む多数のリーフノードを持つノードのセット、各ノードが 2 つの子のハッシュである中間ノードのセットで構成されます。そして最後に、ツリーの「トップ」を表す2つの子のハッシュから形成された単一のルートノード。 マークル木の目的は、ブロック内のデータを断片的に配信できるようにすることです。ノードは、あるソースからブロックのヘッダーのみをダウンロードでき、別のソースからそれらに関連するツリーのごく一部をダウンロードできます。「すべてのデータが正しいこと」が機能する理由は、ハッシュが上向きに伝播するためです。悪意のあるユーザーが偽のトランザクションをマークル木の最下部にスワップしようとすると、この変更により上のノードが変更され、次にその上のノードが変更されます。 最後にツリーのルート、したがってブロックのハッシュを変更し、プロトコルがそれを完全に異なるブロックとして登録するようにします。これは無効なプルーフオブワークとなります。

マークルツリープロトコルは、長期的な持続可能性にとって間違いなく不可欠です。すべてのブロック全体を保存および処理するビットコインネットワークの「フルノード」は、2014 年 4 月の時点でビットコインネットワークで約 15 GB のディスク領域を占有し、月に 1 GB 以上増加しています。現在、これは一部のデスクトップコンピュータで実行可能であり、モバイル端末では実行できません。将来的には、企業と愛好家のみが参加できるようになります。これに対して「簡易支払い検証」（SPV）と呼ばれるプロトコルでは、「ライトノード」と呼ばれる別のクラスのノードが存在できます。このノードは、ブロックヘッダーをダウンロードし、ブロックヘッダーのプルーフオブワークを検証してから、それらに関連するトランザクションに関連付けられた「ブランチ」を生成します。これにより、ライトノードは、ブロックチェーン全体のごく一部のみをダウンロードしながら、ビットコイントランザクションのステータスと現在の残高をセキュリティの強力な保証で判断できます。

### ブロックチェーンテクノロジーの応用 {name=application-of-blockchain-technology}

根底にあるブロックチェーンのアイデアを他のコンセプトに適用するというアイデアにも長い歴史があります。 2005 年、Nick Szabo は、「[所有者権限を持つ安全な所有権](https://nakamotoinstitute.org/secure-property-titles/)」という概念を発表しました。これは、「複製データベース技術の新しい進歩」について説明した文書です。誰がどの土地を所有しているかのレジストリを保存するためのブロックチェーンベースのシステムを可能にし、住宅建設、不利な所有、ジョージアの土地税などの概念を含む精巧なフレームワークを作成します。ただし、残念ながら、当時は効果的な複製データベースシステムが利用できなかったため、プロトコルが実際に実装されることはありませんでした。しかし、2009 年以降、ビットコインの分散型コンセンサスが開発されると、多くの代替アプリケーションが急速に出現し始めました。

- **Namecoin** - 2010 年に作成された[Namecoin](https://namecoin.org/) は、分散型の名前登録データベースとして最もよく説明されています。 Tor、Bitcoin、BitMessage などの分散型プロトコルでは、他の人がアカウントを操作できるようにアカウントを識別する方法が必要ですが、既存のすべてのソリューションで使用できる識別子は、`1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy` のような疑似ランダムハッシュのみです。理想的には、「george」のような名前のアカウントを作成できるようにする必要があります。ただし、問題は、ある人が「george」という名前のアカウントを作成できる場合、他の人が同じプロセスを使用して「george」を自分自身に登録し、偽装できることです。唯一の解決策は、最初の登録者が成功し、2 番目の登録者が失敗する先願主義です。これはビットコインコンセンサスプロトコルに完全に適した問題です。 Namecoin は、そのようなアイデアを使用した名前登録システムの最も古く、最も成功した実装です。
- **Colored coins** - [色付きコイン](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) の目的は、人々が独自のデジタル通貨を作成できるようにするためのプロトコルとして機能することです。ビットコインブロックチェーン上に1つのユニット、デジタルトークンを持つ通貨の重要な些細なケースでは。カラーコインプロトコルでは、特定のビットコイン UTXO に色を公に割り当てることで新しい通貨を「発行」し、プロトコルは他の UTXO の色を、それらを作成するトランザクションが費やした入力の色と同じになるように再帰的に定義します。 （混合色入力の場合、いくつかの特別な規則が適用されます）。これにより、ユーザーは特定の色の UTXO のみを含むウォレットを維持し、通常のビットコインのようにそれらを送信し、ブロックチェーンをバックトラックして、受信する UTXO の色を決定できます。
- **Metacoins** - メタコインの背後にある考え方は、ビットコイン上に存在するプロトコルを持ち、ビットコイントランザクションを使用してメタコイントランザクションを格納しますが、異なる状態遷移関数 `APPLY'` を使用することです。メタコインプロトコルは無効なメタコイントランザクションがビットコインブロックチェーンに現れるのを防ぐことができないため、 `APPLY'(S、TX)` がエラーを返した場合、プロトコルはデフォルトで `APPLY'(S、TX) = S` になります。これは、任意の暗号通貨プロトコルを作成するための簡単なメカニズムを提供します。ビットコイン自体の内部では実装できない高度な機能を備えている可能性がありますが、マイニングとネットワーキングの複雑さはビットコインプロトコルによってすでに処理されているため、開発コストは非常に低くなります。メタコインは、デジタル契約、名前登録、および分散型交換システムを実装するために使用されてきました。

したがって、一般に、コンセンサスプロトコルを構築するには、独立したネットワークを構築する方法と、ビットコイン上にプロトコルを構築する方法の 2 つのアプローチがあります。前者のアプローチは、Namecoin のようなアプリケーションの場合にはかなり成功しますが、実装するのは困難です。個々の実装は、独立したブロックチェーンを boot する必要があります。また、必要なすべての状態遷移とネットワークコードを構築してテストする必要があります。さらに、分散型コンセンサステクノロジーの一連のアプリケーションは、アプリケーションの大部分が小さすぎて独自のブロックチェーンを保証できないべき乗則の分布に従うと予測し、分散型アプリケーション、特に分散型自律組織の大きなクラスが存在することに注意してください。相互に作用する必要のある組織がなければ成立しません。

一方、ビットコインベースのアプローチには、ビットコインの簡略化された支払い検証機能を継承しないという欠点があります。 SPV は、有効性のプロキシとしてブロックチェーンの深さを使用できるため、ビットコインで機能します。ある時点で、トランザクションの祖先が十分に遡ると、彼らは合法的に州の一部であったと言っても過言ではありません。一方、ブロックチェーンベースのメタプロトコルでは、ブロックチェーンに、独自のプロトコルのコンテキスト内で無効なトランザクションを含めないように強制することはできません。したがって、完全に安全な SPV メタプロトコルの実装では、特定のトランザクションが有効かどうかを判断するために、ビットコインブロックチェーンの先頭まで逆方向にスキャンする必要があります。現在、ビットコインベースのメタプロトコルのすべての「軽い」実装は、データを提供するために信頼できるサーバーに依存しています。特に暗号通貨の主な目的の 1 つが信頼の必要性を排除することである場合、おそらく望ましくない結果になります。

// ----- 2022.01.28 ここまでチェック ok ----- //

### 実装記述 {name=scripting}

拡張機能がなくても、ビットコインプロトコルは実際には「スマートコントラクト」の概念をもっています。ビットコインの UTXO は、公開鍵だけでなく、単純なスタックベースのプログラミング言語で表現されたより複雑なスクリプトによっても所有できます。このパラダイムでは、UTXO がスクリプトを満たすデータを提供する必要があるトランザクション支出。実際、基本的な公開鍵所有権メカニズムでさえ、スクリプトを介して実装されます。スクリプトは、入力として楕円曲線署名を受け取り、トランザクションと UTXO を所有するアドレスに対して検証し、検証が成功した場合は1を返し、そうでない場合は0を返します。その他のより複雑なスクリプトは、さまざまな追加のユースケース用に存在します。たとえば、検証するために特定の3つの秘密鍵のうち 2 つからの署名（「マルチシグ」）を必要とするスクリプトを作成できます。これは、企業アカウント、安全な普通預金口座、および一部の商人のエスクロー状況に役立つ設定です。スクリプトを使用して、計算問題の解決策に報奨金を支払うこともできます。また、「この金種の Dogecoin トランザクションを私に送信したことを示す SPV 証明を提供できれば、このビットコインの UTXO はあなたのものです」というようなスクリプトを作成することもできます。 本質的に分散型のクロス暗号通貨交換を可能にします。

ただし、ビットコインに実装されているスクリプト言語にはいくつかの重要な制限があります:

- **チューリング完全性の欠如** - つまり、ビットコインスクリプト言語がサポートする計算の大部分はありますが、すべてをサポートしているわけではありません。欠落している主なカテゴリはループです。これは、トランザクション検証中の無限ループを回避するために行われます。理論的には、スクリプトプログラマーにとっては克服可能な障害です。if ステートメントを使用して基になるコードを何度も繰り返すだけでループをシミュレートできるためですが、スクリプトのスペース効率が非常に悪くなります。たとえば、代替の楕円曲線署名アルゴリズムを実装するには、コードに個別に含まれる 256 回の乗算ラウンドが必要になる可能性があります。
- **価値の盲目** - UTXO スクリプトが、引き出すことができる量をきめ細かく制御する方法はありません。たとえば、強力なユースケースの 1つは信託による利用です。A と B が 1000 ドル相当の BTC を投入し、30日後にスクリプトが 1000 ドル相当の BTC を A に送信し、残りを B に送信するヘッジ契約の場合を想定します。信託内容は USD で 1 BTC の価値を決定しますが、それでも、現在利用可能な完全に集中化されたソリューションよりも、信頼性とインフラストラクチャ要件の点で大幅な改善です。ただし、UTXO　はオールオアナッシングであるため、これを実現する唯一の方法は、さまざまな額面のUTXOを多数持つという非常に非効率的なハックを使用することです（たとえば、kまでのkごとに2 <sup> k </sup>の　UTXO　を　1　つ使用します。 30）Aに送信するUTXOとBに送信するUTXOをOに選択させます。
- **状態の欠如** - UTXOは、使用済みまたは未使用のいずれかです。それを超える他の内部状態を維持する多段階のコントラクトまたはスクリプトの機会はありません。これにより、多段階のオプション契約、分散型交換オファー、または2段階の暗号化コミットメントプロトコル（安全な計算バウンティに必要）を作成することが困難になります。また、UTXOは、単純な1回限りの契約を構築するためにのみ使用でき、分散型組織などのより複雑な「ステートフル」契約を構築するためには使用できず、メタプロトコルの実装を困難にします。値の盲目と組み合わされたバイナリ状態は、別の重要なアプリケーションである引き出し制限が不可能であることも意味します。
- **ブロックチェーン** - UTXO は、ナンス、タイムスタンプ、前のブロックハッシュなどのブロックチェーンデータを認識しません。これにより、スクリプト言語から潜在的に価値のあるランダム性のソースが奪われるため、ギャンブルやその他のいくつかのカテゴリでのアプリケーションが大幅に制限されます。

したがって、暗号通貨の上に高度なアプリケーションを構築するための 3 つのアプローチがあります。新しいブロックチェーンを構築する、ビットコインの上にスクリプトを使用する、そしてビットコインの上にメタプロトコルを構築することです。新しいブロックチェーンを構築すると、機能セットを自由に構築できますが、開発時間、ブートの労力、およびセキュリティが犠牲になります。スクリプトの使用は、実装と標準化が簡単ですが、その機能は非常に制限されており、メタプロトコルは簡単ですが、スケーラビリティの欠点に悩まされています。Ethereum、SYMBOL は異なる視点からこの問題を解決しています。開発の容易さをさらに向上させ、ライトクライアントのプロパティをさらに強化すると同時に、アプリケーションが経済環境とブロックチェーンのセキュリティを共有できるようにする代替フレームワークが構築されています。

## イーサリアム(Ethereum)・シンボル(SYMBOL) {name=ethereum-symbol}

### アカウント方式の状態遷移関数 {name=state-transition-of-account-base}

![state transition flow](https://synquery.github.io/pages/images/state-transition-flow.png)

Ethereum の汎用性は状態遷移定義から明らかです。  
状態遷移関数 `APPLY（S、TX）-> S'` は、次のように定義できます。

1.トランザクションが整形式であり（つまり、適切な数の値を持っている）、署名が有効であり、ナンスが送信者のアカウントのナンスと一致するかどうかを確認します。そうでない場合は、エラーを返します。
2.取引手数料を `STARTGAS * GASPRICE`として計算し、署名から送信アドレスを決定します。送信者のアカウント残高から料金を差し引き、送信者のナンスをインクリメントします。使うのに十分なバランスがない場合は、エラーを返します。
3. `GAS = STARTGAS`を初期化し、トランザクションのバイトに対して支払うために、バイトごとに一定量のガスを取り除きます。
4.トランザクション値を送信者のアカウントから受信者のアカウントに転送します。受信アカウントがまだ存在しない場合は、作成します。受信アカウントが契約である場合は、契約のコードを完了するまで、または実行がガスを使い果たすまで実行します。
5.送信者に十分なお金がなかったため、またはコードの実行でガスがなくなったために値の転送が失敗した場合は、料金の支払いを除くすべての状態変化を元に戻し、料金をマイナーのアカウントに追加します。
6.それ以外の場合は、残りのすべてのガスの料金を送信者に返金し、消費されたガスの料金をマイナーに送信します。

たとえば、契約のコードが次のとおりであるとします:

    if !self.storage[calldataload(0)]:
        self.storage[calldataload(0)] = calldataload(32)

実際には、コントラクトコードは低レベルの EVM:Ethereum Virtual Machine コードで記述されていることに注意してください。この例は、わかりやすくするために高級言語の 1 つである Serpent で記述されており、EVM コードにコンパイルできます。コントラクトのストレージが空で始まり、トランザクションが 10 エーテル値、2000 ガス、0.001 エーテルガス価格、および 64 バイトのデータで送信され、バイト0〜31が数値「2」を表し、バイト32〜63が文字列 `CHARLIE`。この場合の状態遷移関数のプロセスは次のとおりです。

1.トランザクションが有効で整形式であることを確認します。
2.トランザクション送信者が少なくとも2000 \ * 0.001 = 2エーテルを持っていることを確認します。そうである場合は、送信者のアカウントから2エーテルを引きます。
3.ガスの初期化= 2000;トランザクションの長さが170バイトで、バイト料金が5であると仮定すると、850を引いて、1150のガスが残ります。
4.送信者のアカウントからさらに10個のエーテルを差し引き、それを契約のアカウントに追加します。
5.コードを実行します。この場合、これは単純です。インデックス `2`のコントラクトのストレージが使用されているかどうかをチェックし、使用されていないことに気付くため、インデックス` 2`のストレージを値 `CHARLIE`に設定します。これに187のガスが必要であるとすると、ガスの残りの量は1150-187 = 963になります。
6. 963 \ * 0.001 = 0.963 etherを送信者のアカウントに追加し、結果の状態を返します。

トランザクションの受信側に契約がなかった場合、合計トランザクション料金は、提供された「GASPRICE」にトランザクションの長さ（バイト単位）を掛けたものに単純に等しくなり、トランザクションと一緒に送信されるデータは無関係になります。

メッセージは復帰に関してトランザクションと同等に機能することに注意してください。メッセージの実行がガスを使い果たした場合、そのメッセージの実行、およびその実行によってトリガーされた他のすべての実行は復帰しますが、親の実行は復帰する必要はありません。これは、AがGガスでBを呼び出すかのように、契約が別の契約を呼び出すことが「安全」であることを意味します。Aの実行は最大でGガスを失うことが保証されます。最後に、コントラクトを作成するオペコード `CREATE`があることに注意してください。その実行メカニズムは、実行の出力が新しく作成されたコントラクトのコードを決定することを除いて、一般的に `CALL`に似ています。

### 拡張コード {name=extention-code-for-ethereum}

イーサリアム契約のコードは、「イーサリアム仮想マシンコード」または「EVMコード」と呼ばれる低レベルのスタックベースのバイトコード言語で記述されています。コードは一連のバイトで構成され、各バイトは操作を表します。一般に、コードの実行は無限ループであり、現在のプログラムカウンター（ゼロから開始）で操作を繰り返し実行し、コードの最後に到達するかエラーまたは `になるまで、プログラムカウンターを1ずつインクリメントします。 STOP`または `RETURN`命令が検出されました。操作は、データを格納するための3つのタイプのスペースにアクセスできます。

- **スタック**、値をプッシュおよびポップできる後入れ先出しコンテナ
- **メモリ**、無限に拡張可能なバイト配列
- 契約の長期**ストレージ**、キー/バリューストア。計算の終了後にリセットされるスタックやメモリとは異なり、ストレージは長期間存続します。

このコードは、着信メッセージの値、送信者、データ、およびブロックヘッダーデータにアクセスすることもできます。また、コードはデータのバイト配列を出力として返すこともできます。

EVMコードの正式な実行モデルは驚くほど単純です。イーサリアム仮想マシンの実行中、その完全な計算状態はタプル `（block_state、transaction、message、code、memory、stack、pc、gas）`で定義できます。ここで、 `block_state`はすべてのアカウントを含むグローバル状態であり、天びんとストレージが含まれます。実行のすべてのラウンドの開始時に、現在の命令は `code`の` pc`番目のバイト（または `pc> = len（code）`の場合は0）を取得することによって検出され、各命令には独自の定義があります。それがタプルにどのように影響するかについて。たとえば、 `ADD`は2つのアイテムをスタックからポップして合計をプッシュし、` gas`を1減らし、 `pc`を1ずつインクリメントし、` SSTORE`は上位2つのアイテムをスタックからプッシュして、2番目のアイテムをスタックに挿入します。最初のアイテムで指定されたインデックスでのコントラクトのストレージ。ジャストインタイムコンパイルを介してイーサリアム仮想マシンの実行を最適化する方法はたくさんありますが、イーサリアムの基本的な実装は数百行のコードで実行できます。

### ブロックチェーンとマイニング {name=blockchain-and-mining}

![Apply block diagram](https://synquery.github.io/pages/images/apply-block-diagram.png)

イーサリアムブロックチェーンは多くの点でビットコインブロックチェーンに似ていますが、いくつかの違いがあります。ブロックチェーンアーキテクチャに関するイーサリアムとビットコインの主な違いは、ビットコインとは異なり、イーサリアムブロックにはトランザクションリストと最新の状態の両方のコピーが含まれていることです。それとは別に、ブロック番号と難易度の2つの値もブロックに格納されます。イーサリアムの基本的なブロック検証アルゴリズムは次のとおりです:

1.参照されている前のブロックが存在し、有効であるかどうかを確認します。
2.ブロックのタイムスタンプが、参照されている前のブロックのタイムスタンプよりも大きく、15分未満であることを確認します。
3.ブロック番号、難易度、トランザクションルート、叔父ルート、およびガス制限（さまざまな低レベルのイーサリアム固有の概念）が有効であることを確認します。
4.ブロックのプルーフオブワークが有効であることを確認します。
5. `S [0]`を前のブロックの終わりの状態とします。
6. `TX`をブロックのトランザクションリストとし、` n`トランザクションを使用します。 `0 ... n-1`のすべての` i`に対して、 `S [i + 1] = APPLY（S [i]、TX [i]）`を設定します。アプリケーションがエラーを返した場合、またはこの時点までにブロックで消費されたガスの合計が `GASLIMIT`を超えた場合は、エラーを返します。
7.`S_FINAL`を `S [n]`としますが、マイナーに支払われるブロック報酬を追加します。
8.状態 `S_FINAL`のマークルツリールートが、ブロックヘッダーで提供される最終状態ルートと等しいかどうかを確認します。そうである場合、ブロックは有効です。それ以外の場合は無効です。

このアプローチは、各ブロックで状態全体を保存する必要があるため、一見非常に非効率に見えるかもしれませんが、実際には、効率はビットコインの効率に匹敵するはずです。その理由は、状態がツリー構造に格納され、ブロックごとにツリーのごく一部のみを変更する必要があるためです。したがって、一般に、2つの隣接するブロック間では、ツリーの大部分が同じである必要があります。したがって、データは1回保存され、ポインター（つまり、サブツリーのハッシュ）を使用して2回参照できます。これを実現するために、「パトリシアツリー」と呼ばれる特殊な種類のツリーが使用されます。これには、ノードを効率的に変更するだけでなく、挿入および削除できるようにするマークルツリーの概念の変更が含まれます。さらに、すべての状態情報が最後のブロックの一部であるため、ブロックチェーンの履歴全体を保存する必要はありません。ビットコインに適用できる場合は、スペースを5〜20倍節約するために計算できる戦略です。

よくある質問は、物理ハードウェアの観点から、契約コードが「どこで」実行されるかです。これには簡単な答えがあります。コントラクトコードを実行するプロセスは、ブロック検証アルゴリズムの一部である状態遷移関数の定義の一部であるため、トランザクションがブロック `B`に追加されると、そのトランザクションによって生成されるコード実行が発生します。現在および将来、ブロック `B`をダウンロードして検証するすべてのノードによって実行されます。

### Ethereum の発行 {name=generating-for-ethereum}

イーサリアムネットワークには、独自の組み込み通貨であるイーサリアムが含まれています。イーサリアムは、さまざまな種類のデジタル資産間の効率的な交換を可能にする主要な流動性レイヤーを提供し、さらに重要なことに、取引手数料を支払うメカニズムを提供するという2つの目的を果たします。便宜上、そして将来の議論を避けるために（ビットコインでの現在の mBTC / uBTC / satoshi の議論を参照）、大きい単位には事前にラベルが付けられます：

- 1：wei
- 10 <sup> 12 </sup>：szabo
- 10 <sup> 15 </sup>：finney
- 10 <sup> 18 </sup>：ether

これは、「ドル」と「セント」または「BTC」と「satoshi」の概念の拡張バージョンと見なす必要があります。近い将来、通常のトランザクションには「ether」、マイクロトランザクションには「finney」、料金とプロトコルの実装に関する技術的な議論には「szabo」と「wei」が使用される予定です。残りの金種は後で役立つ可能性があり、現時点ではクライアントに含めるべきではありません。

発行モデルは次のようになります。

-　イーサリアムは、BTC あたり 1000〜2000 イーサリアムの価格で通貨販売でリリースされます。これは、イーサリアム組織に資金を提供し、マスターコインや NXT などの他のプラットフォームで成功を収めている開発の支払いを目的としたメカニズムです。以前の購入者は、より大きな割引の恩恵を受けるでしょう。販売から受け取ったBTCは、開発者に給与と報奨金を支払うために完全に使用され、イーサリアムと暗号通貨エコシステムのさまざまな営利および非営利プロジェクトに投資されます。  
-　総販売額の 0.099 倍（60102216 ETH）が組織に割り当てられ、初期の貢献者を補償し、ジェネシスブロックの前に ETH 建ての費用を支払います。  
-　販売総額の 0.099 倍が長期準備金として維持されます。  
-　販売された合計金額の 0.26 倍は、その時点以降、永久に年間のマイナーに割り当てられます。  

| グループ                  | 初期 |  1年後 |  5年後 |
| ---------------------- | --------- | ------------ | ------------- |
| 流通量         | 1.198X    | 1.458X       | 2.498X        |
| 購入者             | 83.5%     | 68.6%        | 40.0%         |
| プリセール | 8.26%     | 6.79%        | 3.96%         |
| ポストセール | 8.26%     | 6.79%        | 3.96%         |
| マイナー報酬                 | 0%        | 17.8%        | 52.0%         |

**長期供給成長率（パーセント）**

![Ethereum inflation](https://synquery.github.io/pages/images/ethereum-inflation.png)

_出典: ethereum.org_  
_直線的な通貨発行にもかかわらず、ビットコインと同じように、時間の経過とともに供給の伸び率はゼロになる傾向があります。_

上記のモデルの 2 つの主な選択肢は、  
（1）寄付プールの存在とサイズ  
（2）ビットコインのように上限のある供給  
とは対照的に、永続的に成長する線形供給の存在です。基金プールの正当性は次のとおりです。基金プールが存在せず、同じインフレ率を提供するために線形発行が0.217倍に減少した場合、エーテルの総量は16.5％少なくなるため、各ユニットの価値は19.8％高くなります。したがって、平衡状態では、19.8％多いエーテルが販売で購入されるため、各ユニットは以前とまったく同じように価値があります。その場合、組織には1.198倍のBTCがあり、これは元のBTCと追加の0.198倍の2つのスライスに分割されていると見なすことができます。したがって、この状況は寄付と「まったく同じ」ですが、重要な違いが1つあります。それは、組織が純粋にBTCを保持しているため、エーテルユニットの価値をサポートするように奨励されていないことです。

永続的な線形供給成長モデルは、ビットコインに過度の富が集中していると見なされるリスクを軽減し、現在および将来の時代に住む個人に通貨単位を取得するための公正な機会を提供すると同時に、取得して保持するための強力なインセンティブを保持しますパーセンテージとしての「供給成長率」は、時間の経過とともにゼロになる傾向があるためです。また、不注意や死亡などによりコインは時間の経過とともに失われ、コインの損失は年間総供給量のパーセンテージとしてモデル化できるため、流通している総通貨供給量は最終的には一定の値で安定するという理論もあります。年間発行額を損失率で割ったものに等しい（たとえば、損失率が1％の場合、供給が26倍に達すると、毎年0.26倍が採掘され、0.26倍が失われ、均衡が保たれます）。

将来的には、イーサリアムがセキュリティのためにプルーフオブステークモデルに切り替わり、発行要件が年間0〜0.05倍に削減される可能性があることに注意してください。イーサリアム組織が資金を失ったり、その他の理由で失踪した場合、私たちは「社会契約」を開いたままにします。イーサリアムの将来の候補バージョンを作成する権利は誰にでもあります。唯一の条件は、イーサリアムの量がせいぜい `60102216 *（1.198 + 0.26 * n）`に等しい。ここで、 `n`は発生ブロック後の年数である。作成者は、PoS主導の供給拡張と、開発に支払う最大許容供給拡張との差の一部またはすべてを、自由にクラウド販売または割り当てます。社会契約に準拠していないアップグレードの候補は、正当に準拠したバージョンに分岐する可能性があります。

### SYMBOL の発行 {name=generating-for-symbol}

SYMBOL ネットワークには、これまでコミュニティに投資した発行済通貨が存在します。
MAINNET が起動する `network.yml` にそのすべてが定義されており、ネットワークはこのファイルに記述された設定を前提として動作します。

- 1：symbol.xym

発行モデルは次のようになります。

-　SYMBOL は、2021年に組織改変を実施し、不死鳥財団による資金管理がされました。これを源泉とし、成功を収めている開発の支払いを目的としたメカニズムが成立しています。ハーベストによって生成される SYMBOL は開発者に給与と報奨金を支払うために使用され、SYMBOL と暗号通貨エコシステムのさまざまな営利および非営利プロジェクトに投資されます。
-　総販売額の 0.099 倍（60102216 ETH）が組織に割り当てられ、初期の貢献者を補償し、ジェネシスブロックの前に ETH 建ての費用を支払います。  
-　販売総額の 0.099 倍が長期準備金として維持されます。  
-　販売された合計金額の 0.26 倍は、その時点以降、永久に年間のマイナーに割り当てられます。  

| グループ                  | 初期 |  1年後 |  5年後 |
| ---------------------- | --------- | ------------ | ------------- |
| 流通量         | 1.198X    | 1.458X       | 2.498X        |
| 購入者             | 83.5%     | 68.6%        | 40.0%         |
| プリセール | 8.26%     | 6.79%        | 3.96%         |
| ポストセール | 8.26%     | 6.79%        | 3.96%         |
| マイナー報酬                 | 0%        | 17.8%        | 52.0%         |

### 集積マイニング {name=aggregation-mining}

ビットコインマイニングアルゴリズムは、マイナーがブロックヘッダーのわずかに変更されたバージョンでSHA256を何百万回も何度も計算するようにすることで機能し、最終的に1つのノードがターゲットよりも小さいバージョン（現在は約2 <sup>192</sup>）を思い付くまで続きます。）。ただし、このマイニングアルゴリズムは、2つの形式の集中化に対して脆弱です。まず、マイニングエコシステムは、ASIC（特定用途向け集積回路）、ビットコインマイニングの特定のタスク用に設計されたコンピューターチップによって支配されるようになりました。これは、ビットコインマイニングがもはや高度に分散化された平等主義的な追求ではなく、効果的に参加するために数百万ドルの資本を必要とすることを意味します。代わりに、ブロックヘッダーを提供するために集中型マイニングプールに依存しています。この問題は間違いなくさらに悪いです：この記事の執筆時点で、上位3つのマイニングプールはビットコインネットワークの処理能力の約50％を間接的に制御していますが、これは、プールがあれば他のマイニングプールに切り替えることができるという事実によって軽減されますまたは連合は51％の攻撃を試みます。


イーサリアムの現在の目的は、マイニングアルゴリズムを使用して、マイナーが状態からランダムデータをフェッチし、ブロックチェーンの最後のNブロックからランダムに選択されたトランザクションを計算し、結果のハッシュを返す必要があることです。これには2つの重要な利点があります。まず、イーサリアムコントラクトにはあらゆる種類の計算を含めることができるため、イーサリアムASICは基本的に一般的な計算用のASICになります。より良いCPU。次に、マイニングではブロックチェーン全体にアクセスする必要があり、マイナーはブロックチェーン全体を保存し、少なくともすべてのトランザクションを検証できるようになります。これにより、一元化されたマイニングプールが不要になります。マイニングプールは、報酬配分のランダム性を排除するという正当な役割を果たしますが、この機能は、中央制御のないピアツーピアプールでも同様に機能します。

このモデルはテストされておらず、契約の実行をマイニングアルゴリズムとして使用する場合、特定の巧妙な最適化を回避するのが難しい場合があります。ただし、このアルゴリズムの特に興味深い機能の1つは、特定のASICを妨害するように特別に設計されたブロックチェーンに多数のコントラクトを導入することにより、誰でも「井戸に毒を盛る」ことができることです。 ASICメーカーがこのようなトリックを使用して相互に攻撃することには、経済的なインセンティブがあります。したがって、私たちが開発しているソリューションは、純粋に技術的なソリューションではなく、最終的には適応型の経済的な人間のソリューションです。


## Synquery crypto-network {name=synquery-crypto-network}

Synquery crypto-network の目的は、Ethereum や SYMBOL と同様、分散型アプリケーションを構築するための代替プロトコルを作成することであり、分散型アプリケーションのプロトコル実装に非常に役立つと思われるさまざまなセットを提供します。ウォレットアプリケーションをはじめ、相互作用するさまざまなアプリケーションが重要なほか、公開されるソースコードとその理念が重要です。Synquery はブロックチェーンテクノロジーの構築時に把握すべき技術的基本層を暗黙化し、構築を容易にすることによって汎用性を高めます。組み込みのチューリング完全プログラミング言語を備えたブロックチェーン、所有権、トランザクション形式、および状態遷移関数など。Ethereum や SYMBOL の基本層を基盤としているため、Namecoin の最低限の実装は、API 1コール記述でき、他のプロトコルへの転移実装においても、複雑そうなものをいとも簡単に物理量に変換し組み込むことができます。特定の条件が満たされた場合にのみロックを解除する暗号化ボックスもプラットフォーム上に構築でき、価値認識、ブロックチェーン認識および状態管理、チューリング完全性など良いところはそのまま継承しています。

現在暗号資産における「決済」システムを提供しているのは取引所です。取引所は換金機能を提供し、その手数料を徴収しています。
取引所で交換され法定通貨となることで実際に社会に繋がる時、暗号資産は見えないものになってしまいます。
暗号資産が本来保有する金融能力以外の価値、それはコミュニティベースでプロジェクトを加速させる能力ですが、が社会から切り離されることはハイボラティリティに目がいきがちな暗号資産の仕組みの中で、見過ごされてきた課題です。

`LAB` はユーザーのオフラインでの決済を完全に保証するとともに、その履行に対して報酬を付与することで、決済の利用意欲をかきたてます。
決済時に生成された `LAB` がオンラインで照合されると、そこにエアドロップが生じます。
このエアドロップは長期準備金から支出されます。`LAB` の生成量により配分された暗号資産は、配布以降いつでも利用可能です。
例えば `betasynet` では 1 日あたり

    2,600.283415 * (60 / 30) * 60 * 24 = 7,488,816.2352 xyn
    
のハーベスティングが継続されています。
15分間の `LAB` 生成を 2,000 人が行なった場合、一人あたりおよそ `374.4xyn` のリターンを受けることになります。
とても穏和な生成の場合です。トランザクションとインフレーションの状態によってはより多くの価値を受け取ることになるでしょう。
またとても良いことに、報酬は配布されたその時点から利用可能です。

### Synquery crypto states {name=synquery-crypto-states}

状態は「アカウント」と呼ばれるオブジェクトで構成され、各アカウントに「アドレス」があり、「アドレス」をまとめて「プロファイル」を構成します。状態遷移はアカウント間の値と情報の直接転送です。アカウント方式と UTXO 方式では双方に長所・短所があります。
  
**拡張性** 1つの残高を保存するには、そのユーザーが所有するすべてのUTXOを保存するよりも、はるかに少ないメモリしか必要としないため、アカウントモデルはより効率的な方法でメモリを利用します。アカウントモデルのトランザクションは、送信者、受信者、金額、デジタル署名のみを必要とするため、サイズも小さくなります。Ethereum の各トランザクションは約 100 バイトですが、UTXO モデルのトランザクションは通常その数倍になります。一方で、UTXO モデルに固有の検証メカニズムにより、ライトニングネットワークなどの決済チャネルの開発に適した設計になっています。また、UTXOのトランザクションは並列化が可能なため、UTXOベースのブロックチェーンをシャードやサイドチェーンに分割することが容易になります。UTXO モデルでは、クライアント側で出力を集約して定義することができるため、ネットワークの計算要件が軽減されます。UTXO モデルでは、クライアント側で出力を集約して定義することができるため、ネットワークの計算量を減らすことができます。
  
**プライバシー** UTXO モデルでは、アドレスの切り替えが容易であるため、コインの所有権を追跡することが難しくなります。新たに生成されたアドレスには公開された所有者がおらず、特定のユーザーに結びつけるためには通常、高度なチェーン分析が必要となります。アカウントモデルでは1つのアドレスの再利用が推奨されているため、このようなブロックチェーンでは取引履歴の特定が非常に容易になります。一方で、アカウントモデルはファンジビリティの点でより優れたプライバシーを提供しています。先ほどのUTXOの例で考えると、アリスのウォレットにある3.7BTCのUTXOが、ボブの3BTCと0.8BTCのUTXOから生成されたものであることを、第三者が容易に推測することができます。アカウントモデルでは、複数の取引で資金を得たウォレットは単一の残高で表されるため、そのような関連性はありません。アリスが自分のウォレットからETHを使うことがあっても、そのETHがボブから来たものなのか、他の誰かから来たものなのか、誰にもわからないのです。
  
**スマートコントラクト機能** アカウントベースの取引は単純で直感的なため、スマートコントラクトの機能面で大きなメリットがあります。単数の残高を検証することは、UTXO の入出力ロジックを計算するよりも計算負荷が低く、分散型アプリ（DApp）の開発者が複数の当事者間の契約や取引をプログラムすることを容易にしています。例えば、Ethereum Virtual Machine（EVM）では、複数のスマートコントラクト間の取引を、それぞれの残高を調整するだけで処理することができます。UTXO モデルは、各取引において明示的な UTXO の入力と出力を必要とするため、より多くのリソースを必要とします。UTXO モデルでプログラムされたスマートコントラクトは、組み合わせるべき入力の数や、複数の選択肢がある場合にどの入力を組み合わせるべきかを考慮する必要があります。

**セキュリティ**　ビットコインなどの UTXO ブロックチェーンでは、バリデータ・ノードが UTXO セットを追跡し、どのコインが流通しているか、誰が所有しているかを正確に把握します。各トランザクションは、使用される正確な UTXO を参照しなければならないため、このシステムは二重支出の問題を信頼性のある効率的な方法で解決します。アカウントモデルのブロックチェーンは、はるかに脆弱であることが証明されており、チャージバックやスマートコントラクトの過多など、他の問題に悩まされることがよくあります。UTXO モデルで使用される明確に定義された入力と出力の代わりに、アカウントモデルでは、仮想マシンによって正確さをチェックしなければならない「イベント」を使用します。例えば、Ethereum Classic プロジェクトでは、2020年にかけての一連の二重支出攻撃で数百万ドルの損失が発生しました。

「synquery.xyn（仮）」は Synquery crypto-network の主要な運営のための燃料であり、アドレス間で取引手数料の支払いに使用されます。一般的に、アカウントには 2つのタイプがあります: **seed account**, 秘密鍵によって制御され、 **mnemonic accounts** 契約コードによって制御されます。外部所有のアカウントにはコードがなく、トランザクションを作成して署名することにより、外部所有のアカウントからメッセージを送信できます。コントラクトアカウントでは、コントラクトアカウントがメッセージを受信するたびに、そのコードがアクティブになり、内部ストレージの読み取りと書き込み、他のメッセージの送信、またはコントラクトの作成が可能になります。

Synquery crypto-network の「契約」は、Ethereum や SYMBOL と同様、「履行」または「遵守」されるべきものと見なされるべきではないことに注意してください。むしろ、それらは実行環境内に存在する「自律エージェント」のようなものであり、メッセージまたはトランザクションによって「動かされた」ときに常に特定のコードを実行し、独自バランスと独自のキーを直接制御し、永続的に変数を追跡可能とする記憶媒体の意味もあります。

### 報酬システム {name=synquery-crypto-revenue}

これまブロックチェーンの維持のために用いられてきたプロトコルで代表的なものには PoW、PoS、PoS+ があります。これらはどれも非常に優秀に機能した実績を持っています。PoW は計算量が報酬に直結するため、その単純性からビットコインを躍進させた原動力になりました。より多数のエンジニアがネットワークで活躍できるよう、PoS、 PoS+ が生まれ、ブロックチェーンシステムは市民権を得るまでに成長しました。

現在のブロックチェーンの課題は何でしょうか。各仮想通貨は目論見通り機能しているように見えます。しかし実際にはステークする人としない人の温度差は自明であり、ネットワークフライホイールとしての暗号資産の目論見は道半ばです。驚異的なボラティリティで一世を風靡した SHIB コインは、本当に芝犬保護に賛同した人たちが押し上げたのでしょうか。それは嘘ではないとは思いますが、賛同者が実際に芝犬保護に投資以外の「何か」をアクションしているかどうかはプロトコル外であるため、立証しようがありません。

我々はこの問題を解決して、ネットワークの維持のステータスにトランザクションメーカー自体の計画と遂行に対して時間に応じて報酬を発生させる PoSy を提案しました。我々のアイデアはいくつかの暗号資産（特にミームコインと呼ばれるようなもの）にみられる投機的なデザインを変更するものです。PoSy による配分は PoS+ 上に実装されるため、各ノードグループの裁量に依存しますが、利用者は利用ノードを自身で選択できるため、よりパワフルに報酬を発生させるノードグループの優位性が高くなります。

PoS+ のスコアに還元率 `R` を設定するところまではこれまでの暗号資産のスキームと同じです。Synquery crypto-network ではこの還元率の配分を SYMBOL システムを承継した委任によるのではなく、各アドレスのコントリビューションスコアで自動配分します。コントリビューションスコアは `LAB` と呼ばれるアドレスごとのブロックより導出されます。ただし、承認で発生されるコントリビューションスコアはノード運営者の裁量に任せられているので、ここで利用者と運営者の接点・相互作用を生み出します。こだわりある利用者はより還元率が高く、コントリビューションスコアを上げてくれるノードを利用するでしょう。（もちろん安定性等が求められるのはこれまで通りでしょう！）

### アクションブロックとトランザクション {name=synquery-crypto-message}

「トランザクション」という用語は、Synquery crypto-network では、外部所有のアカウントから送信されるメッセージを格納する署名付きデータパッケージを指すために使用されます。トランザクションには次のものが含まれます:

- メッセージの受信者
- 送信者を識別する署名
- 送信者から受信者に転送するエーテル（通貨および付随情報）の量
- `transaction-fee` 値。送信者が計算ステップごとに支払う料金を表します
- オプションのデータフィールド

最初の3つは、任意の暗号通貨で期待される標準フィールドです。データフィールドにはデフォルトでは機能がありませんが、仮想マシンには、コントラクトがデータにアクセスするために使用します。ユースケースの例として、コントラクトがオンブロックチェーンドメイン登録サービスとして機能している場合、渡されるデータを2つの「フィールド」を含むものとして解釈したい場合があります。最初のフィールドは登録するドメインで、2番目のフィールドは登録するドメインです。フィールドは、登録するIPアドレスです。コントラクトは、メッセージデータからこれらの値を読み取り、適切にストレージに配置します。

`transaction-fee` フィールドと` max-fee` フィールドは、サービス拒否防止モデルにとって非常に重要です。コード内の偶発的または敵対的な無限ループやその他の計算の浪費を防ぐために、各トランザクションでは、使用できるコード実行の計算ステップ数に制限を設定する必要があります。計算の基本単位は暗号資産の最小単位です。通常、計算ステップのコストは `0.01 xyn` ですが、一部の操作では、計算コストが高くなるため、または状態の一部として保存する必要のあるデータの量が増えるため、量が多くなります。また、トランザクションデータのバイトごとに `5ガス` の料金がかかります。料金システムの目的は、攻撃者が、計算、帯域幅、ストレージなど、消費するすべてのリソースに比例して支払うことを要求することです。したがって、ネットワークがこれらのリソースのいずれかをより多く消費することにつながるトランザクションには、増分にほぼ比例したガス料金が必要です。

基本的に、メッセージはトランザクションに似ていますが、外部のアクターではなく契約によって生成される点が異なります。メッセージは、現在コードを実行しているコントラクトがメッセージを生成して実行する `CALL`オペコードを実行するときに生成されます。トランザクションのように、メッセージはそのコードを実行している受信者アカウントにつながります。したがって、契約は、外部のアクターとまったく同じ方法で他の契約と関係を持つことができます。

トランザクションまたは契約によって割り当てられたガス許容量は、そのトランザクションおよびすべてのサブ実行によって消費されたガスの合計に適用されることに注意してください。たとえば、外部アクターAが1000ガスでトランザクションをBに送信し、BがCにメッセージを送信する前に600ガスを消費し、Cの内部実行が戻る前に300ガスを消費する場合、Bは実行する前にさらに100ガスを消費できます。ガス欠。

### 手数料 {name=synquery-crypto-fees}

ブロックチェーンに公開されたすべてのトランザクションは、ダウンロードして検証する必要があるコストをネットワークに課すため、悪用を防ぐために、通常はトランザクション料金を含む何らかの規制メカニズムが必要です。ビットコインで使用されるデフォルトのアプローチは、純粋に自発的な料金を支払うことであり、鉱山労働者がゲートキーパーとして機能し、動的な最小値を設定することに依存しています。このアプローチは、特に「市場ベース」であり、マイナーとトランザクション送信者の間の需要と供給が価格を決定できるため、ビットコインコミュニティで非常に好評です。ただし、この一連の推論の問題は、トランザクション処理が市場ではないことです。マイナーが送信者に提供しているサービスとしてトランザクション処理を解釈することは直感的に魅力的ですが、実際には、マイナーが含むすべてのトランザクションはネットワーク内のすべてのノードで処理される必要があるため、トランザクションのコストの大部分は処理はサードパーティが負担し、それを含めるかどうかを決定するマイナーではありません。したがって、コモンズの悲劇の問題が発生する可能性が非常に高くなります。

ただし、市場ベースのメカニズムにこの欠陥があることが判明したため、特定の不正確な単純化の仮定が与えられると、魔法のようにそれ自体がキャンセルされます。議論は次のとおりです。仮定：

1.トランザクションは `k`操作につながり、` R`が送信者によって設定され、 `k`と` R`が（大まかに）マイナーに事前に表示されている場合、それを含むすべてのマイナーに報酬 `kR`を提供します。
2.操作には、任意のノードに対して「C」の処理コストがかかります（つまり、すべてのノードの効率が同じです）。
3.「N」個のマイニングノードがあり、それぞれが正確に等しい処理能力（つまり、合計の「1 / N」）を持っています。
4.マイニング以外のフルノードは存在しません。

期待される報酬がコストよりも大きい場合、マイナーは喜んでトランザクションを処理します。したがって、マイナーは次のブロックを処理する可能性が「1 / N」であり、マイナーの処理コストは単純に「kC」であるため、期待される報酬は「kR / N」です。したがって、マイナーには、 `kR / N> kC`または` R> NC`のトランザクションが含まれます。 `R`は送信者によって提供される操作ごとの料金であり、したがって送信者がトランザクションから得る利益の下限であり、` NC`は操作の処理を合わせたネットワーク全体のコストであることに注意してください。したがって、マイナーは、功利主義の総利益がコストを超える取引のみを含めるインセンティブを持っています。

ただし、実際には、これらの仮定からいくつかの重要な逸脱があります。

1.マイナーは、他の検証ノードよりもトランザクションの処理に高いコストを支払います。これは、追加の検証時間がブロックの伝播を遅らせ、ブロックが古くなる可能性が高くなるためです。
2.マイニング以外のフルノードが存在します。
3.マイニング配電は、実際には根本的に非合法的になる可能性があります。
4.効用機能にネットワークへの害をもたらすことを含む投機家、政敵、狂気は存在し、他の検証ノードによって支払われるコストよりもはるかに低いコストで巧妙に契約を結ぶことができます。

（1）マイナーがより少ないトランザクションを含む傾向を提供し、
（2） `NC`を増やします。したがって、これら2つの効果は少なくとも部分的に
お互いをキャンセルする<sup>[How？](https://github.com/ethereum/wiki/issues/447#issuecomment-316972260)</sup>
（3）と（4）が主要な問題です。それらを解決するために、私たちは単に
フローティングキャップ：どのブロックもより多くの操作を行うことはできません
`BLK_LIMIT_FACTOR`に長期指数移動平均を掛けます。
具体的には：

    blk.oplimit = floor((blk.parent.oplimit \* (EMAFACTOR - 1) +
    floor(parent.opcount \* BLK\_LIMIT\_FACTOR)) / EMA\_FACTOR)

`BLK_LIMIT_FACTOR`と` EMA_FACTOR`は、当面は 65536 と 1.5 に設定される定数ですが、さらに分析した後で変更される可能性があります。

ビットコインの大きなブロックサイズを阻害する別の要因があります。大きなブロックは伝播に時間がかかるため、ストールになる可能性が高くなります。イーサリアムでは、ガスを大量に消費するブロックは、物理的に大きく、検証のためにトランザクション状態遷移を処理するのに時間がかかるため、伝播に時間がかかる場合があります。この遅延の阻害要因はビットコインでは重要な考慮事項ですが、GHOSTプロトコルのためにイーサリアムではそれほど重要ではありません。したがって、規制されたブロック制限に依存することで、より安定したベースラインが提供されます。

### 実行環境とチューリング完全性 {name=synquery-crypto-environment}

重要な点は、Synquery crypto-network Environment はチューリング完全な言語上にあり、これは、設計者が意図したプロトコルを実装可能な環境であることを意味します。コントラクトは他のコントラクトを呼び出すことができ、再帰をループできる可能性があります。これは当然問題につながります。悪意のあるユーザーは、無限ループに入るように強制することで、本質的にマイナーとフルノードをシャットダウンできますか？この問題は、停止問題として知られるコンピュータサイエンスの問題が原因で発生します。一般的なケースでは、特定のプログラムが停止するかどうかを判断する方法はありません。

私たちのソリューションは、トランザクションに実行可能な最大数の計算ステップを設定するように要求することで機能します。実行に時間がかかる場合は、計算が元に戻されますが、料金は支払われます。メッセージは同じように機能します。ソリューションの背後にある動機を示すために、次の例を検討してください。

- 攻撃者は、無限ループを実行するコントラクトを作成し、そのループをアクティブ化するトランザクションをマイナーに送信します。マイナーはトランザクションを処理し、無限ループを実行して、ガスがなくなるのを待ちます。実行がガスを使い果たして途中で停止したとしても、トランザクションは引き続き有効であり、マイナーは計算ステップごとに攻撃者から料金を請求します。
- 攻撃者は、非常に長い無限ループを作成し、マイナーに計算を長時間継続させることを目的として、計算が終了するまでにさらにいくつかのブロックが出てきて、マイナーが料金を請求するためのトランザクション。ただし、攻撃者は `STARTGAS`の値を送信して、実行できる計算ステップの数を制限する必要があります。そのため、マイナーは、計算に非常に多くのステップがかかることを事前に知っています。
- 攻撃者は、 `send（A、contract.storage [A]）;のような形式のコードを持つ契約を確認します。 Contract.storage [A] = 0`であり、最初のステップを実行するのに十分なガスを使用してトランザクションを送信しますが、2番目のステップは実行しません（つまり、引き出しを行いますが、残高を下げません）。実行が途中で停止すると変更が元に戻されるため、契約作成者はそのような攻撃からの保護について心配する必要はありません。
- 金融契約は、リスクを最小限に抑えるために、9つの独自のデータフィードの中央値を取ることによって機能します。攻撃者は、DAOのセクションで説明されている可変アドレス呼び出しメカニズムを介して変更できるように設計されたデータフィードの1つを乗っ取り、それを無限ループを実行するように変換します。ガスを使い果たすための金融契約。ただし、金融契約では、この問題を防ぐためにメッセージにガス制限を設定できます。

チューリング完全性の代替手段はチューリング完全性であり、 `JUMP`と` JUMPI`は存在せず、各コントラクトのコピーは常にコールスタックに1つだけ存在できます。このシステムでは、契約を実行するためのコストがそのサイズによって制限されるため、説明されている料金システムとソリューションの有効性に関する不確実性は必要ない場合があります。さらに、チューリング完全性はそれほど大きな制限ではありません。私たちが社内で考案したすべての契約例のうち、これまでのところループが必要なのは1つだけであり、そのループでさえ、1行のコードを26回繰り返すことで削除できます。チューリング完全性の深刻な影響と限られた利点を考えると、チューリング不完全言語を単純に持ってみませんか？ただし、実際には、チューリング完全性は問題の適切な解決策にはほど遠いです。理由を確認するには、次の契約を検討してください。

    C0: call(C1); call(C1);
    C1: call(C2); call(C2);
    C2: call(C3); call(C3);
    ...
    C49: call(C50); call(C50);
    C50: (run one step of a program and record the change in storage)

ここで、トランザクションをAに送信します。したがって、51のトランザクションで、2 <sup> 50 </sup>の計算ステップを必要とするコントラクトがあります。マイナーは、実行可能な計算ステップの最大数を指定する各コントラクトの横の値を維持し、他のコントラクトを再帰的に呼び出すコントラクトについてこれを計算することで、このようなロジック爆弾を事前に検出しようとする可能性がありますが、マイナーは、作成するコントラクトを禁止する必要がありますその他の契約（上記の26の契約すべての作成と実行は、簡単に1つの契約にまとめることができるため）。もう1つの問題点は、メッセージのアドレスフィールドが変数であるため、一般に、特定のコントラクトが他のどのコントラクトを呼び出すかを事前に判断することさえできない場合があることです。したがって、全体として、驚くべき結論が得られます。チューリング完全性の管理は驚くほど簡単であり、チューリング完全性の欠如は、まったく同じ制御が行われていない限り、同様に驚くほど管理が困難です。プロトコルをチューリング完全にしますか？

### 通貨と発行 {name=generating-this-crypto}

イーサリアムネットワークには、独自の組み込み通貨であるイーサリアムが含まれています。イーサリアムは、さまざまな種類のデジタル資産間の効率的な交換を可能にする主要な流動性レイヤーを提供し、さらに重要なことに、取引手数料を支払うメカニズムを提供するという2つの目的を果たします。便宜上、そして将来の議論を避けるために（ビットコインでの現在のmBTC / uBTC /サトシの議論を参照）、金種には事前にラベルが付けられます：

- 1：wei
- 10 <sup> 12 </sup>：szabo
- 10 <sup> 15 </sup>：フィニー
- 10 <sup> 18 </sup>：エーテル

これは、「ドル」と「セント」または「BTC」と「サトシ」の概念の拡張バージョンと見なす必要があります。近い将来、通常のトランザクションには「ether」、マイクロトランザクションには「finney」、料金とプロトコルの実装に関する技術的な議論には「szabo」と「wei」が使用される予定です。残りの金種は後で役立つ可能性があり、現時点ではクライアントに含めるべきではありません。

発行モデルは次のようになります。

-　イーサリアムは、BTCあたり1000〜2000イーサリアムの価格で通貨販売でリリースされます。これは、イーサリアム組織に資金を提供し、マスターコインやNXTなどの他のプラットフォームで成功を収めている開発の支払いを目的としたメカニズムです。以前の購入者は、より大きな割引の恩恵を受けるでしょう。販売から受け取ったBTCは、開発者に給与と報奨金を支払うために完全に使用され、イーサリアムと暗号通貨エコシステムのさまざまな営利および非営利プロジェクトに投資されます。
-　総販売額の0.099倍（60102216 ETH）が組織に割り当てられ、初期の貢献者を補償し、ジェネシスブロックの前にETH建ての費用を支払います。
-　販売総額の0.099倍が長期準備金として維持されます。
-　販売された合計金額の0.26倍は、その時点以降、永久に年間のマイナーに割り当てられます。

| Group                  | At launch | After 1 year | After 5 years |
| ---------------------- | --------- | ------------ | ------------- |
| Currency units         | 1.198X    | 1.458X       | 2.498X        |
| Purchasers             | 83.5%     | 68.6%        | 40.0%         |
| Reserve spent pre-sale | 8.26%     | 6.79%        | 3.96%         |
| Reserve used post-sale | 8.26%     | 6.79%        | 3.96%         |
| Miners                 | 0%        | 17.8%        | 52.0%         |

**長期供給成長率（パーセント）**

![Ethereum inflation](./ethereum-inflation.png)

_直線的な通貨発行にもかかわらず、ビットコインと同じように、時間の経過とともに供給の伸び率はゼロになる傾向があります。_

上記のモデルの2つの主な選択肢は、（1）寄付プールの存在とサイズ、および（2）ビットコインのように上限のある供給とは対照的に、永続的に成長する線形供給の存在です。基金プールの正当性は次のとおりです。基金プールが存在せず、同じインフレ率を提供するために線形発行が0.217倍に減少した場合、エーテルの総量は16.5％少なくなるため、各ユニットの価値は19.8％高くなります。したがって、平衡状態では、19.8％多いエーテルが販売で購入されるため、各ユニットは以前とまったく同じように価値があります。その場合、組織には1.198倍のBTCがあり、これは元のBTCと追加の0.198倍の2つのスライスに分割されていると見なすことができます。したがって、この状況は寄付と「まったく同じ」ですが、重要な違いが1つあります。それは、組織が純粋にBTCを保持しているため、エーテルユニットの価値をサポートするように奨励されていないことです。

永続的な線形供給成長モデルは、ビットコインに過度の富が集中していると見なされるリスクを軽減し、現在および将来の時代に住む個人に通貨単位を取得するための公正な機会を提供すると同時に、取得して保持するための強力なインセンティブを保持しますパーセンテージとしての「供給成長率」は、時間の経過とともにゼロになる傾向があるためです。また、不注意や死亡などによりコインは時間の経過とともに失われ、コインの損失は年間総供給量のパーセンテージとしてモデル化できるため、流通している総通貨供給量は最終的には一定の値で安定するという理論もあります。年間発行額を損失率で割ったものに等しい（たとえば、損失率が1％の場合、供給が26倍に達すると、毎年0.26倍が採掘され、0.26倍が失われ、均衡が保たれます）。

将来的には、イーサリアムがセキュリティのためにプルーフオブステークモデルに切り替わり、発行要件が年間0〜0.05倍に削減される可能性があることに注意してください。イーサリアム組織が資金を失ったり、その他の理由で失踪した場合、私たちは「社会契約」を開いたままにします。イーサリアムの将来の候補バージョンを作成する権利は誰にでもあります。唯一の条件は、イーサリアムの量がせいぜい `60102216 *（1.198 + 0.26 * n）`に等しい。ここで、 `n`は発生ブロック後の年数である。作成者は、PoS主導の供給拡張と、開発に支払う最大許容供給拡張との差の一部またはすべてを、自由にクラウド販売または割り当てます。社会契約に準拠していないアップグレードの候補は、正当に準拠したバージョンに分岐する可能性があります。

### 集積マイニング {name=delegation-mining}

ビットコインマイニングアルゴリズムは、マイナーがブロックヘッダーのわずかに変更されたバージョンでSHA256を何百万回も何度も計算するようにすることで機能し、最終的に1つのノードがターゲットよりも小さいバージョン（現在は約2 <sup> 192）を思い付くまで続きます。 </ sup>）。ただし、このマイニングアルゴリズムは、2つの形式の集中化に対して脆弱です。まず、マイニングエコシステムは、ASIC（特定用途向け集積回路）、ビットコインマイニングの特定のタスク用に設計されたコンピューターチップによって支配されるようになりました。これは、ビットコインマイニングがもはや高度に分散化された平等主義的な追求ではなく、効果的に参加するために数百万ドルの資本を必要とすることを意味します。代わりに、ブロックヘッダーを提供するために集中型マイニングプールに依存しています。この問題は間違いなくさらに悪いです：この記事の執筆時点で、上位3つのマイニングプールはビットコインネットワークの処理能力の約50％を間接的に制御していますが、これは、プールがあれば他のマイニングプールに切り替えることができるという事実によって軽減されますまたは連合は51％の攻撃を試みます。


イーサリアムの現在の目的は、マイニングアルゴリズムを使用して、マイナーが状態からランダムデータをフェッチし、ブロックチェーンの最後のNブロックからランダムに選択されたトランザクションを計算し、結果のハッシュを返す必要があることです。これには2つの重要な利点があります。まず、イーサリアムコントラクトにはあらゆる種類の計算を含めることができるため、イーサリアムASICは基本的に一般的な計算用のASICになります。より良いCPU。次に、マイニングではブロックチェーン全体にアクセスする必要があり、マイナーはブロックチェーン全体を保存し、少なくともすべてのトランザクションを検証できるようになります。これにより、一元化されたマイニングプールが不要になります。マイニングプールは、報酬配分のランダム性を排除するという正当な役割を果たしますが、この機能は、中央制御のないピアツーピアプールでも同様に機能します。

このモデルはテストされておらず、契約の実行をマイニングアルゴリズムとして使用する場合、特定の巧妙な最適化を回避するのが難しい場合があります。ただし、このアルゴリズムの特に興味深い機能の1つは、特定のASICを妨害するように特別に設計されたブロックチェーンに多数のコントラクトを導入することにより、誰でも「井戸に毒を盛る」ことができることです。 ASICメーカーがこのようなトリックを使用して相互に攻撃することには、経済的なインセンティブがあります。したがって、私たちが開発しているソリューションは、純粋に技術的なソリューションではなく、最終的には適応型の経済的な人間のソリューションです。

### 拡張性 {name=extention}

イーサリアムに関する一般的な懸念の1つは、スケーラビリティの問題です。ビットコインと同様に、イーサリアムには、すべてのトランザクションをネットワーク内のすべてのノードで処理する必要があるという欠陥があります。ビットコインを使用すると、現在のブロックチェーンのサイズは約15 GBになり、1時間あたり約1MBずつ増加します。ビットコインネットワークがVisaの2000トランザクション/秒を処理する場合、3秒あたり1 MB（1時間あたり1 GB、1年あたり8 TB）増加します。イーサリアムは同様の成長パターンに苦しむ可能性があり、ビットコインの場合のように通貨だけでなくイーサリアムブロックチェーンの上に多くのアプリケーションがあるという事実によって悪化しますが、イーサリアムのフルノードが保存する必要があるという事実によって改善されますブロックチェーンの履歴全体ではなく、状態のみ。

このような大きなブロックチェーンサイズの問題は、集中化のリスクです。ブロックチェーンのサイズがたとえば100TBに増加した場合、考えられるシナリオは、ごく少数の大企業のみがフルノードを実行し、すべての通常のユーザーがライトSPVノードを使用することです。このような状況では、完全なノードが団結し、すべてが何らかの有益な方法でチートすることに同意する可能性があるという潜在的な懸念が生じます（たとえば、ブロック報酬を変更し、自分自身にBTCを与えます）。ライトノードには、これをすぐに検出する方法がありません。もちろん、少なくとも1つの正直なフルノードが存在する可能性があり、数時間後、詐欺に関する情報がRedditなどのチャネルを介して流出しますが、その時点では遅すぎます。通常のユーザーが整理する必要があります。与えられたブロックをブラックリストに載せる努力、成功した51％の攻撃を成功させるのと同様の規模で、大規模で実行不可能な可能性のある調整の問題。ビットコインの場合、これは現在問題ですが、ブロックチェーンの変更が存在します[Peter Toddが提案](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/) これにより、この問題が軽減されます。

短期的には、イーサリアムはこの問題に対処するために2つの追加戦略を使用します。まず、ブロックチェーンベースのマイニングアルゴリズムにより、少なくともすべてのマイナーがフルノードになるように強制され、フルノードの数に下限が作成されます。ただし、2つ目はさらに重要なことですが、各トランザクションを処理した後、ブロックチェーンに中間状態のツリールートを含めます。ブロック検証が集中化されている場合でも、正直な検証ノードが1つ存在する限り、検証プロトコルを介して集中化の問題を回避できます。マイナーが無効なブロックを公開した場合、そのブロックのフォーマットが正しくないか、状態 `S [n]`が正しくありません。 `S [0]`は正しいことがわかっているので、 `S [i-1]`が正しい場合は正しくない最初の状態 `S [i]`が存在する必要があります。検証ノードは、 `APPLY（S [i-1]、TX [i]）-> S [iを処理する必要があるパトリシアツリーノードのサブセットで構成される「無効の証明」とともに、インデックス` i`を提供します。 ] `。ノードはそれらのノードを使用して計算のその部分を実行でき、生成された `S [i]`が提供された `S [i]`と一致しないことを確認できます。

もう1つのより洗練された攻撃には、悪意のあるマイナーが不完全なブロックを公開することが含まれるため、ブロックが有効かどうかを判断するための完全な情報すら存在しません。これに対する解決策はチャレンジレスポンスプロトコルです。検証ノードはターゲットトランザクションインデックスの形式で「チャレンジ」を発行し、ノードを受信すると、ライトノードは、マイナーまたは別のベリファイアが提供するまで、別のノードがブロックを信頼できないものとして扱います。有効性の証明としてのPatriciaノードのサブセット。

## アプリケーション {name=applications}

一般に、イーサリアムの上に3つのタイプのアプリケーションがあります。最初のカテゴリは金融アプリケーションであり、ユーザーが自分のお金を使用して契約を管理および締結するためのより強力な方法を提供します。これには、サブ通貨、金融デリバティブ、ヘッジ契約、貯蓄ウォレット、意志、そして最終的には本格的な雇用契約のいくつかのクラスが含まれます。 2番目のカテゴリーは半金融アプリケーションであり、お金が関係しますが、行われていることに金銭以外の重い側面もあります。完璧な例は、計算問題の解決のための自己強制的な報奨金です。最後に、オンライン投票や分散型ガバナンスなど、まったく経済的ではないアプリケーションがあります。

### トークンシステム {name=token-systems}

オンブロックチェーントークンシステムには、USDや金などの資産を表すサブ通貨から会社の株式、スマートプロパティを表す個々のトークン、安全な偽造不可能なクーポン、さらには従来の価値とはまったく関係のないトークンシステムまで、さまざまなアプリケーションがあり、ポイントとして使用されますインセンティブのためのシステム。トークンシステムは、イーサリアムに驚くほど簡単に実装できます。理解しておくべき重要なポイントは、すべての通貨またはトークンシステムは、基本的に1つの操作でデータベースであるということです。AからX単位を減算し、BにX単位を与えます。ただし、（i）Aの前に少なくともX単位があった場合トランザクションおよび（2）トランザクションはAによって承認されます。トークンシステムを実装するために必要なのは、このロジックをコントラクトに実装することだけです。

Serpentでトークンシステムを実装するための基本的なコードは次のとおりです。

    def send(to, value):
        if self.storage[msg.sender] >= value:
            self.storage[msg.sender] = self.storage[msg.sender] - value
            self.storage[to] = self.storage[to] + value

これは本質的に、このドキュメントでさらに説明した「バンキングシステム」状態遷移関数の文字通りの実装です。そもそも通貨単位を配布する最初のステップと他のいくつかのエッジケースを提供するために、コードを数行追加する必要があります。理想的には、他の契約が住所の残高を照会できるようにする関数が追加されます。 。しかし、それだけです。理論的には、サブ通貨として機能するイーサリアムベースのトークンシステムには、オンチェーンビットコインベースのメタ通貨にはない別の重要な機能が含まれる可能性があります。それは、その通貨で直接取引手数料を支払う機能です。これを実装する方法は、契約が、送信者に料金を支払うために使用されたエーテルを返金するエーテル残高を維持し、手数料を受け取る内貨単位を収集して再販することにより、この残高を補充することです。継続的に実行されるオークション。したがって、ユーザーはetherを使用してアカウントを「アクティブ化」する必要がありますが、etherが存在すると、契約によって毎回返金されるため、再利用できます。

### 金融デリバティブと安定した価値の通貨 {name=financial-derivatives-and-stable-value-currencies}

金融デリバティブは「スマートコントラクト」の最も一般的なアプリケーションであり、コードで実装するのが最も簡単なものの1つです。金融契約を実施する際の主な課題は、それらの大部分が外部の価格ティッカーへの参照を必要とすることです。たとえば、非常に望ましいアプリケーションは、米ドルに対するイーサリアム（または別の暗号通貨）のボラティリティをヘッジするスマートコントラクトですが、これを行うには、ETH / USDの値を知る必要があります。これを行う最も簡単な方法は、特定の当事者（NASDAQなど）が維持する「データフィード」契約を使用して、その当事者が必要に応じて契約を更新できるように設計し、他の契約がその契約にメッセージを送り、価格を提供する応答を返します。

その重要な要素を考えると、ヘッジ契約は次のようになります:

1.パーティAが1000エーテルを入力するのを待ちます。
2.パーティBが1000エーテルを入力するのを待ちます。
3.データフィード契約をクエリして計算された1000エーテルのUSD値をストレージに記録します。これは、$ xであると言います。
4. 30日後、AまたはBが契約を「再アクティブ化」して、$ x相当のエーテル（新しい価格を取得するためにデータフィード契約を再度クエリして計算）をAに送信し、残りをBに送信できるようにします。

そのような契約は、暗号商取引において大きな可能性を秘めています。暗号通貨について引用された主な問題の1つは、それが揮発性であるという事実です。多くのユーザーや商人は暗号資産を扱う際のセキュリティと利便性を望んでいるかもしれませんが、1日で資金の価値の23％を失うという見通しに直面することを望まない人も少なくありません。これまで、最も一般的に提案されたソリューションは、発行者が支援する資産でした。アイデアは、発行者がユニットを発行および取り消す権利を持つサブ通貨を作成し、指定された原資産（例：金）の1ユニットを（オフラインで）提供する人に通貨の1ユニットを提供するというものです。 、 米ドル）。次に、発行者は、暗号資産の1ユニットを返送するすべての人に原資産の1ユニットを提供することを約束します。このメカニズムにより、発行者が信頼できる場合、暗号化されていないアセットを暗号化アセットに「アップリフト」することができます。

ただし、実際には、発行者は常に信頼できるとは限らず、場合によっては、銀行のインフラストラクチャが弱すぎたり、敵対的すぎたりして、そのようなサービスが存在しません。金融デリバティブは代替手段を提供します。ここでは、資産をバックアップするための資金を提供する単一の発行者の代わりに、暗号化参照資産（ETHなど）の価格が上がることを賭けて、投機家の分散型市場がその役割を果たします。発行者とは異なり、ヘッジ契約はエスクローに資金を保有しているため、投機家は交渉の側でデフォルトするオプションがありません。価格ティッカーを提供するには信頼できるソースが必要であるため、このアプローチは完全に分散化されていないことに注意してください。ただし、これはインフラストラクチャ要件の削減という点で大幅な改善です（発行者である場合とは異なり、価格フィードの発行にはライセンスは必要ありません）。言論の自由として分類される可能性があります）、詐欺の可能性を減らします。

### アイデンティティと評判システム {name=identity-and-reputation-systems}

すべての中で最も初期の代替暗号通貨である[Namecoin](http://namecoin.org/) は、ビットコインのようなブロックチェーンを使用して名前登録システムを提供しようとしました。このシステムでは、ユーザーは他のデータと一緒に自分の名前を公開データベースに登録できます。引用されている主な使用例は、[DNS](http://en.wikipedia.org/wiki/Domain_Name_System) システムで、「bitcoin.org」（またはNamecoinの場合は「bitcoin.bit」）のようなドメイン名をマッピングします。 IPアドレスに。その他のユースケースには、電子メール認証や、より高度なレピュテーションシステムが含まれる可能性があります。イーサリアムでネームコインのような名前登録システムを提供するための基本契約は次のとおりです:

    def register(name, value):
        if !self.storage[name]:
            self.storage[name] = value

契約は非常に簡単です。イーサリアムネットワーク内のデータベースであり、追加したり、変更したり、削除したりすることはできません。誰でも何らかの価値のある名前を登録することができ、その登録は永久に存続します。より洗練された名前登録契約には、他の契約がそれを照会できるようにする「関数句」と、名前の「所有者」（つまり最初の登録者）がデータを変更したり所有権を譲渡したりするメカニズムもあります。レピュテーションとWeb-of-Trust機能を追加することもできます。

### 分散型ファイルストレージ {name=decentralized-file-storage}

過去数年間で、多くの人気のあるオンラインファイルストレージスタートアップが登場しました。最も有名なのはDropboxで、ユーザーがハードドライブのバックアップをアップロードし、サービスにバックアップを保存してユーザーがアクセスできるようにすることを目指しています。月額料金と引き換えに。ただし、現時点では、ファイルストレージ市場は比較的非効率的である場合があります。さまざまな既存のソリューションをざっと見てみると、特に無料の割り当てもエンタープライズレベルの割引も開始されない「不気味の谷」の20〜200 GBレベルでは、主流のファイルストレージコストの月額料金が高額になっていることがわかります。 1か月のハードドライブ全体のコストよりも。イーサリアムの契約により、分散型ファイルストレージエコシステムの開発が可能になります。このエコシステムでは、個々のユーザーが自分のハードドライブをレンタルすることで少額のお金を稼ぐことができ、未使用のスペースを使用してファイルストレージのコストをさらに削減できます。

このようなデバイスの重要な基盤となるのは、「分散型Dropbox契約」と呼ばれるものです。この契約は次のように機能します。まず、必要なデータをブロックに分割し、プライバシーのために各ブロックを暗号化し、そこからマークルツリーを構築します。次に、Nブロックごとに、コントラクトがMerkleツリー内のランダムインデックスを選択し（前のブロックハッシュを使用して、ランダム性のソースとしてコントラクトコードからアクセス可能）、Xエーテルを与えるというルールでコントラクトを作成します。ツリー内の特定のインデックスでブロックの所有権を証明するような、簡略化された支払い検証をトランザクションに提供する最初のエンティティ。ユーザーがファイルを再ダウンロードしたい場合は、マイクロペイメントチャネルプロトコルを使用して（たとえば、32キロバイトごとに1 szaboを支払う）、ファイルを回復できます。最も料金効率の高いアプローチは、支払人が最後までトランザクションを公開せず、代わりに32キロバイトごとに同じナンスを持つわずかに収益性の高いトランザクションに置き換えることです。

プロトコルの重要な機能は、ファイルを忘れないように多くのランダムノードを信頼しているように見えるかもしれませんが、秘密共有を介してファイルを多数の部分に分割することにより、そのリスクをほぼゼロに減らすことができることです。契約を監視して各部分を確認することは、まだ一部のノードが所有しています。契約がまだお金を払っている場合、それはそこにいる誰かがまだファイルを保存しているという暗号の証拠を提供します。

### 分散型自律組織 {name=decentralized-autonomous-organizations}

「分散型自律組織」の一般的な概念は、特定のメンバーまたは株主のセットを持ち、おそらく67％の過半数で、エンティティの資金を使用してそのコードを変更する権利を持つ仮想エンティティの概念です。メンバーは、組織がその資金をどのように配分するかを集合的に決定します。 DAOの資金を割り当てる方法は、報奨金、給与から、仕事に報いるための内貨などのさらにエキゾチックなメカニズムにまで及ぶ可能性があります。これは基本的に、従来の企業または非営利団体の法的な罠を複製しますが、施行には暗号化ブロックチェーンテクノロジーのみを使用します。これまでのところ、DAOに関する話題の多くは、配当を受け取る株主と取引可能な株式を持つ「分散型自律組織」（DAC）の「資本主義」モデルに関するものでした。おそらく「分散型自律コミュニティ」と呼ばれる代替案では、すべてのメンバーが意思決定に平等に関与し、既存のメンバーの67％がメンバーの追加または削除に同意する必要があります。その場合、1人のメンバーが1つのメンバーシップしか持てないという要件は、グループによってまとめて適用される必要があります。

DAOのコーディング方法の概要は次のとおりです。最も単純な設計は、メンバーの3分の2が変更に同意した場合に変更される自己変更コードの一部です。コードは理論的には不変ですが、コードのチャンクを別々のコントラクトに入れ、呼び出すコントラクトのアドレスを変更可能なストレージに格納することで、これを簡単に回避し、事実上の可変性を持たせることができます。このようなDAO契約の単純な実装では、トランザクションで提供されるデータによって区別される3つのトランザクションタイプがあります:

- `[0、i、K、V]`は、プロポーザルをインデックス `i`に登録し、ストレージインデックス` K`のアドレスを値 `V`に変更します。
- `[0、i]`は提案 `i`に賛成票を投じる
- 十分な投票が行われた場合、提案 `i`を完成させるための` [2、i] `

その場合、契約にはこれらのそれぞれについての条項があります。開いているすべてのストレージの変更の記録と、それらに投票した人のリストが保持されます。また、すべてのメンバーのリストもあります。ストレージの変更が投票するメンバーの3分の2に達すると、ファイナライズトランザクションが変更を実行する可能性があります。より洗練されたスケルトンには、トランザクションの送信、メンバーの追加、メンバーの削除などの機能に対する投票機能も組み込まれており、[Liquid Democracy]（http://en.wikipedia.org/wiki/Delegative_democracy）-を提供することもできます。スタイルの投票委任（つまり、誰でも誰かに投票を割り当てることができ、割り当ては推移的であるため、AがBを割り当て、BがCを割り当てる場合、CがAの投票を決定します）。この設計により、DAOは分散型コミュニティとして有機的に成長し、最終的にはメンバーを除外するタスクをスペシャリストに委任できますが、「現在のシステム」とは異なり、スペシャリストは時間の経過とともに簡単に出入りできます。個々のコミュニティメンバーが配置を変更すると。

別のモデルは、分散型企業の場合です。この場合、どのアカウントでも0個以上の株式を所有でき、意思決定には株式の3分の2が必要です。完全なスケルトンには、資産管理機能、株式の売買の申し出を行う機能、および申し出を受け入れる機能（できれば契約内の注文照合メカニズムを使用）が含まれます。代表団はまた、「取締役会」の概念を一般化する、流動的民主主義スタイルで存在するでしょう。

### その他のアプリケーション {name=further-applications}

**1. 貯蓄財布** アリスが自分の資金を安全に保ちたいが、彼女が失うか、誰かが彼女の秘密鍵をハッキングするのではないかと心配しているとします。彼女は次のように、銀行であるボブとエーテルを契約します:

- アリスだけでも、1日あたり最大1％の資金を引き出すことができます。
- ボブだけでも1日あたり最大1％の資金を引き出すことができますが、アリスは自分の鍵を使ってこの能力を遮断して取引を行うことができます。
- アリスとボブは一緒に何でも撤回することができます。

通常、アリスは1日あたり1％で十分です。アリスがさらに引き出したい場合は、ボブに連絡して支援を求めることができます。アリスの鍵がハッキングされた場合、彼女はボブに駆け寄り、資金を新しい契約に移します。彼女が鍵を紛失した場合、ボブは最終的に資金を引き出します。ボブが悪意のあることが判明した場合、彼女は彼の撤退能力をオフにすることができます。

**2. 作物保険** 金融デリバティブ契約を簡単に結ぶことができますが、物価指数の代わりに天気のデータフィードを使用します。アイオワ州の農民がアイオワ州の降水量に反比例して支払うデリバティブを購入した場合、干ばつが発生した場合、農民は自動的にお金を受け取り、十分な雨が降れば、農民は作物がうまくいくので幸せになります。これは一般的に自然災害保険に拡大することができます。

**3. 分散型データフィード** 差金決済取引の場合、実際には「[SchellingCoin]（http://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal」と呼ばれるプロトコルを介してデータフィードを分散化できる可能性があります。 -データフィード/）"。 SchellingCoinは基本的に次のように機能します。N人のパーティ全員が特定のデータの値（ETH / USD価格など）をシステムに入れ、値が並べ替えられ、25パーセンタイルから75パーセンタイルまでのすべての人が報酬として1つのトークンを受け取ります。誰もが他の誰もが提供する答えを提供するインセンティブを持っており、多数のプレーヤーが現実的に同意できる唯一の価値は、明らかなデフォルトである真実です。これにより、ETH / USDの価格、ベルリンの気温、または特定のハード計算の結果など、理論的には任意の数の値を提供できる分散型プロトコルが作成されます。

**4. スマートマルチシグニチャエスクロー** ビットコインは、たとえば、与えられた5つのキーのうち3つが資金を使うことができるマルチシグニチャトランザクション契約を許可します。イーサリアムはより細かい粒度を可能にします。たとえば、5人に4人はすべてを費やすことができ、5人に3人は1日あたり最大10％を費やすことができ、5人に2人は1日あたり最大0.5％を費やすことができます。さらに、Ethereum multisigは非同期です。2つのパーティが異なる時間にブロックチェーンに署名を登録でき、最後の署名が自動的にトランザクションを送信します。

**5. クラウドコンピューティング** EVMテクノロジを使用して、検証可能なコンピューティング環境を作成することもできます。これにより、ユーザーは他のユーザーに計算の実行を依頼し、オプションで、ランダムに選択された特定のチェックポイントでの計算が正しく行われたことの証明を要求できます。これにより、すべてのユーザーがデスクトップ、ラップトップ、または専用サーバーに参加できるクラウドコンピューティング市場を構築できます。また、敷金と一緒にスポットチェックを使用して、システムが信頼できることを確認できます（つまり、ノードが利益を上げて不正行為を行うことはできません）。 。このようなシステムはすべてのタスクに適しているわけではありませんが、たとえば、高レベルのプロセス間通信を必要とするタスクは、ノードの大規模なクラウドでは簡単に実行できません。ただし、他のタスクは並列化がはるかに簡単です。 SETI @ home、folding @ home、遺伝的アルゴリズムなどのプロジェクトは、このようなプラットフォーム上に簡単に実装できます。

**6. ピアツーピアギャンブル** フランク・スタジャーノやリチャード・クレイトンの[Cyber​​dice]（http://www.cl.cam.ac.uk/~fms27/papers/2008-StajanoCla-cyberdice.pdf）など、ピアツーピアのギャンブルプロトコルはいくつでもあります。イーサリアムブロックチェーンに実装できます。最も単純なギャンブルプロトコルは、実際には次のブロックハッシュの差金決済取引であり、そこからより高度なプロトコルを構築して、不正行為のないほぼゼロの料金でギャンブルサービスを作成できます。

**7. 予測市場** オラクルまたはSchellingCoinがあれば、予測市場も簡単に実装できます。予測市場は、SchellingCoinとともに、ガバナンスとしての[futarchy]（http://hanson.gmu.edu/futarchy.html）の最初の主流アプリケーションになる可能性があります。分散型組織のためのプロトコル。

**8. オンチェーンの分散型マーケットプレイス** IDおよびレピュテーションシステムをベースとして使用します。


## 結論 {name=conclusion}

Synquery crypto-network のプロトコルは暗号通貨のアップグレードバージョンとして考案され、一般的な高級言語を用いて、ブロックチェーン上のエスクロー、引き出し制限、金融契約、ギャンブル市場などの高度な機能の実現提供します。Synquery crypto-network プロトコルは、どのアプリケーションも直接は「サポート」しませんが、理論的には、任意のトランザクションタイプまたはアプリケーションに対して任意のコントラクトを作成できることを意味します。
Synquery crypto-network についてさらに興味深いのは、Local Action Block(LAB) の存在です。これまで計算量およびコンピューティング能力の提供に関した分散型ファイルストレージ、分散型計算、分散型予測市場を取り巻くプロトコルは、他の数十の概念の中でも、計算業界の効率を大幅に向上させ、他のピアツーピアプロトコルに追加することで大幅な向上をもたらす可能性があります。初めての経済層。最後に、お金とはまったく関係のないアプリケーションも多数あります。

イーサリアムプロトコルによって実装される任意の状態遷移関数の概念は、独自の可能性を備えたプラットフォームを提供します。イーサリアムは、データストレージ、ギャンブル、金融などの特定のアプリケーションを対象としたクローズドエンドの単一目的プロトコルではなく、設計上オープンエンドであり、基盤として機能するのに非常に適していると考えています。今後数年間で、非常に多くの金融プロトコルと非金融プロトコルの両方のレイヤー。

## その他と懸念事項 {name=other}

### 変更された GHOST 実装 {name=changed-ghost-implementation}

「GreedyHeaviestObserved Subtree」（GHOST）プロトコルは、[2013年12月]（https://eprint.iacr.org/2013/881.pdf）でYonatanSompolinskyとAvivZoharによって最初に導入されたイノベーションです。 GHOSTの背後にある動機は、確認時間が速いブロックチェーンは、古いレートが高いために現在セキュリティが低下していることです-マイナーAがブロックをマイニングした後、マイナーBが別のブロックをマイニングした場合、ブロックがネットワークを介して伝播するのに一定の時間がかかるためですマイナーAのブロックがBに伝播する前に、マイナーBのブロックは無駄になり、ネットワークセキュリティに寄与しなくなります。さらに、集中化の問題があります。マイナーAが30％のハッシュパワーを備えたマイニングプールであり、Bが10％のハッシュパワーを備えている場合、Aは70％の確率で古いブロックを生成するリスクがあります（残りの30％の確率でAは最後のブロックを生成したため、すぐにマイニングデータを取得します）が、Bは90％の確率で古いブロックを生成するリスクがあります。したがって、ブロック間隔が十分に短く、失効率が高くなる場合、Aは、そのサイズのおかげで、実質的により効率的になります。これらの2つの効果を組み合わせると、ブロックをすばやく生成するブロックチェーンは、マイニングプロセスを事実上制御するのに十分な割合のネットワークハッシュパワーを持つ1つのマイニングプールにつながる可能性が非常に高くなります。

SompolinskyとZoharによって説明されているように、GHOSTは、どのチェーンが「最長」であるかの計算に古いブロックを含めることにより、ネットワークセキュリティ損失の最初の問題を解決します。つまり、ブロックの親とそれ以降の祖先だけでなく、ブロックの祖先の古い子孫（イーサリアムの専門用語では「おじ」）も、どのブロックが最大の合計プルーフオブワークを持つかを計算するために追加されます。それを裏付ける仕事。集中化バイアスの2番目の問題を解決するために、SompolinskyとZoharによって説明されたプロトコルを超えて、ストールにブロック報酬を提供します。古いブロックは基本報酬の87.5％を受け取り、古いブロックを含む甥は残りを受け取ります。 12.5％。ただし、おじには取引手数料はかかりません。

イーサリアムは、7レベルしか下がらない簡略化されたバージョンのGHOSTを実装しています。具体的には、次のように定義されています。

-ブロックは親を指定する必要があり、0人以上の叔父を指定する必要があります
-ブロックBに含まれる叔父は、次のプロパティを持っている必要があります。
  -Bのk番目の世代の祖先の直接の子である必要があります。ここで2 <= k <= 7です。
  -Bの祖先になることはできません
  -叔父は有効なブロックヘッダーである必要がありますが、以前に検証された、または有効なブロックである必要はありません
  -叔父は、前のブロックに含まれているすべての叔父および同じブロックに含まれている他のすべての叔父とは異なる必要があります（非二重包含）
-ブロックBのすべての叔父Uについて、Bのマイナーはコインベースの報酬に追加の3.125％を受け取り、Uのマイナーは標準のコインベースの報酬の93.75％を受け取ります。

この限定バージョンのGHOSTは、7世代までしか含まれない叔父がいるため、2つの理由で使用されました。まず、無制限のGHOSTは、特定のブロックのどの叔父が有効であるかの計算に非常に多くの複雑さを含みます。第二に、イーサリアムで使用されている補償付きの無制限のゴーストは、マイナーがパブリックアタッカーのチェーンではなくメインチェーンでマイニングするインセンティブを取り除きます。

## 補足情報・関連資料 {name=references}

<!--Invisible HTML comment used for navigation with CTRL+F footnote or fn.-->

### 補足{name=notes}

1. 有識者の方は、実際にはビットコインアドレスが
公開鍵ではなく、楕円曲線暗号（Elliptic Curve Cryptography:ECC）公開鍵のハッシュ値であることをご存じでしょう。
通常、公開鍵ハッシュ自体を公開鍵と呼ぶことができます。これは、ハッシュ値がビットコインの暗号化のカスタムと見なすことができるためです。
公開鍵で構成されるデジタル署名アルゴリズム、ECC 公開鍵のハッシュ、署名は ECC 公開鍵で構成されます。
ECC 署名、および検証アルゴリズムと連結署名の ECC 公開鍵を ECC と照合する必要があります。
公開鍵として提供され、ECC を検証する公開鍵ハッシュ ECC 公開鍵に対する署名。
2. 技術的には、前の 11 ブロックの中央値。
3. 内部的には、2 と「CHARLIE」は両方とも数字であり、後者は
ビッグエンディアンベース 256 表現。数字は少なくとも0であり、最大で2 <sup> 256 </sup> -1 です。
    
### もっと学ぶには {name=more}

1.  [(Bitcoin Magazine) Intrinsic value](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)
2.  [(Wiki) Smart property](https://en.bitcoin.it/wiki/Smart_Property)
3.  [(Wiki) Smart contracts](https://en.bitcoin.it/wiki/Contracts)
4.  [(Weidai) B-money](http://www.weidai.com/bmoney.txt)
5.  [(SNI) Reusable proofs of work](https://nakamotoinstitute.org/finney/rpow/)
6.  [(SNI) Secure property titles with owner authority](https://nakamotoinstitute.org/secure-property-titles/)
7.  [(bitcoin.org) Bitcoin whitepaper](http://bitcoin.org/bitcoin.pdf)
8.  [(namecoin.org) Namecoin](https://namecoin.org/)
9.  [(Wiki) Zooko's triangle](https://en.wikipedia.org/wiki/Zooko's_triangle)
10. [(Google Docs) Colored coins whitepaper](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)
11. [(Github) Mastercoin whitepaper](https://github.com/mastercoin-MSC/spec)
12. [(Bitcoin Magazine) Decentralized autonomous corporations, Bitcoin Magazine](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)
13. [() Simplified payment verification](https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification)
14. [() Merkle trees](https://en.wikipedia.org/wiki/Merkle_tree)
15. [() Patricia trees](https://en.wikipedia.org/wiki/Patricia_tree)
16. [() GHOST](https://eprint.iacr.org/2013/881.pdf)
17. [() StorJ and Autonomous Agents, Jeff Garzik](http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html)
18. [() Mike Hearn on Smart Property at Turing Festival](http://www.youtube.com/watch?v=Pu4PAMFPo5Y)
19. [() Ethereum RLP](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP)
20. [() Ethereum Merkle Patricia trees](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree)
21. [() Peter Todd on Merkle sum trees](http://sourceforge.net/p/bitcoin/mailman/message/31709140/)

_ホワイトペーパーの履歴については、https://github.com/synquery-org-website/src/pages/learn/whitepaper-ja.md を参照ください。_

_このコミュニティ主体のオープンソースソフトウェアプロジェクトはコンピュータサイエンスにおける Human well-being の一端を担うべく、はじまったばかりです。どのような情報が我々、そして Synquery を導いたのか、その背景を詳しく知るには [ガイド](/learn/) を参照してください。_
